<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factory Floor Visualizer - Claude Code Agent Workflows</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            background: #0a0a12;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        /* Header Controls */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 16px 24px;
            background: linear-gradient(180deg, rgba(10, 10, 18, 0.95) 0%, rgba(10, 10, 18, 0) 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            pointer-events: none;
        }

        #header > * {
            pointer-events: auto;
        }

        #header h1 {
            font-size: 14px;
            font-weight: 600;
            color: #a0a0b0;
            letter-spacing: 0.5px;
        }

        #header h1 span {
            color: #6366f1;
        }

        .header-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid rgba(99, 102, 241, 0.3);
            background: rgba(99, 102, 241, 0.1);
            color: #a0a0f0;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .btn:hover {
            background: rgba(99, 102, 241, 0.2);
            border-color: rgba(99, 102, 241, 0.5);
        }

        .btn-primary {
            background: rgba(99, 102, 241, 0.3);
            border-color: rgba(99, 102, 241, 0.5);
        }

        /* File Input Styling */
        #file-input {
            display: none;
        }

        /* Stats Display */
        #stats {
            position: fixed;
            top: 60px;
            right: 24px;
            background: rgba(15, 15, 25, 0.9);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 11px;
            z-index: 90;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            gap: 24px;
            margin-bottom: 4px;
        }

        .stat-row:last-child {
            margin-bottom: 0;
        }

        .stat-label {
            color: #606080;
        }

        .stat-value {
            color: #a0a0f0;
            font-weight: 500;
        }

        /* Timeline Scrubber */
        #timeline {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 15, 25, 0.95);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            padding: 16px 24px;
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 100;
            min-width: 500px;
        }

        #timeline.hidden {
            display: none;
        }

        .timeline-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 1px solid rgba(99, 102, 241, 0.3);
            background: rgba(99, 102, 241, 0.1);
            color: #a0a0f0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .timeline-btn:hover {
            background: rgba(99, 102, 241, 0.3);
        }

        .timeline-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        #timeline-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(99, 102, 241, 0.2);
            border-radius: 3px;
            outline: none;
        }

        #timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }

        #timeline-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }

        .timeline-time {
            font-size: 12px;
            color: #808090;
            min-width: 80px;
            text-align: center;
        }

        .speed-select {
            padding: 6px 10px;
            border: 1px solid rgba(99, 102, 241, 0.3);
            background: rgba(99, 102, 241, 0.1);
            color: #a0a0f0;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
        }

        /* Info Panel */
        #info-panel {
            position: fixed;
            top: 50%;
            right: 24px;
            transform: translateY(-50%);
            background: rgba(15, 15, 25, 0.95);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            padding: 20px;
            width: 320px;
            max-height: 70vh;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        #info-panel.visible {
            display: block;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            color: #e0e0e0;
        }

        .panel-subtitle {
            font-size: 11px;
            color: #606080;
            margin-top: 4px;
        }

        .panel-close {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: none;
            background: rgba(255, 100, 100, 0.1);
            color: #ff6464;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .panel-close:hover {
            background: rgba(255, 100, 100, 0.2);
        }

        .panel-section {
            margin-bottom: 16px;
        }

        .panel-section-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #606080;
            margin-bottom: 8px;
        }

        .panel-stat {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(99, 102, 241, 0.1);
        }

        .panel-stat:last-child {
            border-bottom: none;
        }

        .panel-stat-label {
            color: #808090;
            font-size: 12px;
        }

        .panel-stat-value {
            color: #e0e0e0;
            font-size: 12px;
            font-weight: 500;
        }

        .status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-idle {
            background: rgba(100, 100, 120, 0.2);
            color: #808090;
        }

        .status-working {
            background: rgba(99, 102, 241, 0.2);
            color: #818cf8;
        }

        .status-complete {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
        }

        .status-error {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
        }

        .tool-list {
            font-size: 11px;
        }

        .tool-item {
            padding: 4px 8px;
            background: rgba(99, 102, 241, 0.1);
            border-radius: 4px;
            margin-bottom: 4px;
            color: #a0a0f0;
        }

        /* JSON Preview */
        .json-preview {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 12px;
            font-size: 10px;
            overflow-x: auto;
            max-height: 200px;
            overflow-y: auto;
        }

        .json-preview pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Welcome Screen */
        #welcome {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 50;
        }

        #welcome h2 {
            font-size: 24px;
            font-weight: 300;
            color: #606080;
            margin-bottom: 16px;
        }

        #welcome p {
            font-size: 13px;
            color: #404060;
            margin-bottom: 24px;
            line-height: 1.6;
        }

        #welcome .btn {
            font-size: 14px;
            padding: 12px 24px;
        }

        /* Legend */
        #legend {
            position: fixed;
            bottom: 100px;
            left: 24px;
            background: rgba(15, 15, 25, 0.9);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 11px;
            z-index: 90;
        }

        .legend-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #606080;
            margin-bottom: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .legend-label {
            color: #808090;
        }

        /* Real-time indicator */
        #realtime-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 6px;
            font-size: 11px;
            color: #4ade80;
        }

        #realtime-indicator.active {
            display: flex;
        }

        .pulse-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            overflow: hidden;
        }

        .mode-toggle button {
            padding: 8px 12px;
            border: none;
            background: transparent;
            color: #606080;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }

        .mode-toggle button.active {
            background: rgba(99, 102, 241, 0.2);
            color: #a0a0f0;
        }

        .mode-toggle button:hover:not(.active) {
            background: rgba(99, 102, 241, 0.1);
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(99, 102, 241, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(99, 102, 241, 0.2);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(99, 102, 241, 0.3);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Header -->
    <div id="header">
        <h1><span>Factory Floor</span> Visualizer</h1>
        <div class="header-controls">
            <div id="realtime-indicator">
                <div class="pulse-dot"></div>
                <span>Real-time</span>
            </div>
            <div class="mode-toggle">
                <button id="mode-historical" class="active">Historical</button>
                <button id="mode-realtime">Real-time</button>
            </div>
            <input type="file" id="file-input" accept=".jsonl" multiple>
            <button class="btn btn-primary" id="load-btn">Load Transcript</button>
            <button class="btn" id="reset-btn">Reset View</button>
        </div>
    </div>

    <!-- Stats -->
    <div id="stats">
        <div class="stat-row">
            <span class="stat-label">Agents</span>
            <span class="stat-value" id="stat-agents">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Events</span>
            <span class="stat-value" id="stat-events">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Tokens</span>
            <span class="stat-value" id="stat-tokens">0</span>
        </div>
    </div>

    <!-- Welcome Screen -->
    <div id="welcome">
        <h2>Welcome to the Factory Floor</h2>
        <p>Load a Claude Code session transcript to visualize<br>agent workflows as an animated factory.</p>
        <button class="btn btn-primary" id="welcome-load-btn">Load JSONL Transcript</button>
    </div>

    <!-- Legend -->
    <div id="legend">
        <div class="legend-title">Agent Types</div>
        <div class="legend-item">
            <div class="legend-color" style="background: #6366f1;"></div>
            <span class="legend-label">Orchestrator</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #06b6d4;"></div>
            <span class="legend-label">Researcher / Explorer</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #a855f7;"></div>
            <span class="legend-label">Writer / Editor</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #14b8a6;"></div>
            <span class="legend-label">Analyzer / Validator</span>
        </div>
    </div>

    <!-- Timeline -->
    <div id="timeline" class="hidden">
        <button class="timeline-btn" id="play-btn" title="Play/Pause">
            <svg id="play-icon" viewBox="0 0 24 24"><polygon points="5,3 19,12 5,21"/></svg>
            <svg id="pause-icon" viewBox="0 0 24 24" style="display:none;"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
        </button>
        <span class="timeline-time" id="current-time">0:00</span>
        <input type="range" id="timeline-slider" min="0" max="100" value="0">
        <span class="timeline-time" id="total-time">0:00</span>
        <select class="speed-select" id="speed-select">
            <option value="0.5">0.5x</option>
            <option value="1" selected>1x</option>
            <option value="2">2x</option>
            <option value="5">5x</option>
            <option value="10">10x</option>
        </select>
    </div>

    <!-- Info Panel -->
    <div id="info-panel">
        <div class="panel-header">
            <div>
                <div class="panel-title" id="panel-title">Station Info</div>
                <div class="panel-subtitle" id="panel-subtitle">Agent ID</div>
            </div>
            <button class="panel-close" id="panel-close">&times;</button>
        </div>
        <div id="panel-content"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ============================================
        // CONSTANTS & COLOR PALETTE
        // ============================================
        const COLORS = {
            background: 0x0a0a12,
            floor: 0x12121a,
            grid: 0x1a1a2a,
            // Agent types
            orchestrator: 0x6366f1,  // Indigo
            researcher: 0x06b6d4,    // Cyan
            writer: 0xa855f7,        // Purple
            analyzer: 0x14b8a6,      // Teal
            default: 0x64748b,       // Slate
            // Status colors
            idle: 0x64748b,
            working: 0x3b82f6,
            complete: 0x22c55e,
            error: 0xef4444,
            // UI
            conveyor: 0x1e293b,
            conveyorActive: 0x334155,
            workItem: 0x818cf8
        };

        const AGENT_TYPE_COLORS = {
            'orchestrator': COLORS.orchestrator,
            'general-purpose': COLORS.orchestrator,
            'Explore': COLORS.researcher,
            'explore': COLORS.researcher,
            'researcher': COLORS.researcher,
            'Plan': COLORS.writer,
            'plan': COLORS.writer,
            'writer': COLORS.writer,
            'lead-writer': COLORS.writer,
            'Bash': COLORS.analyzer,
            'bash': COLORS.analyzer,
            'analyzer': COLORS.analyzer,
            'validator': COLORS.analyzer
        };

        // ============================================
        // THREE.JS SCENE SETUP
        // ============================================
        class FactoryScene {
            constructor(container) {
                this.container = container;
                this.stations = new Map();
                this.conveyors = [];
                this.workItems = [];
                this.selectedObject = null;

                this.init();
                this.animate();
            }

            init() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(COLORS.background);

                // Camera - Isometric setup
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 15;
                this.camera = new THREE.OrthographicCamera(
                    -frustumSize * aspect,
                    frustumSize * aspect,
                    frustumSize,
                    -frustumSize,
                    0.1,
                    1000
                );

                // Isometric angle (35.264Â°)
                const isoAngle = Math.atan(1 / Math.sqrt(2));
                this.camera.position.set(20, 20, 20);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.container.appendChild(this.renderer.domElement);

                // Controls
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.maxPolarAngle = Math.PI / 2.2;
                this.controls.minDistance = 10;
                this.controls.maxDistance = 50;

                // Lighting
                this.setupLighting();

                // Floor
                this.createFloor();

                // Raycaster for interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                // Event listeners
                window.addEventListener('resize', () => this.onResize());
                this.renderer.domElement.addEventListener('click', (e) => this.onClick(e));
            }

            setupLighting() {
                // Ambient light
                const ambient = new THREE.AmbientLight(0x404060, 0.4);
                this.scene.add(ambient);

                // Main directional light
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
                mainLight.position.set(10, 20, 10);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 2048;
                mainLight.shadow.mapSize.height = 2048;
                mainLight.shadow.camera.near = 0.5;
                mainLight.shadow.camera.far = 50;
                mainLight.shadow.camera.left = -20;
                mainLight.shadow.camera.right = 20;
                mainLight.shadow.camera.top = 20;
                mainLight.shadow.camera.bottom = -20;
                this.scene.add(mainLight);

                // Fill light
                const fillLight = new THREE.DirectionalLight(0x6366f1, 0.3);
                fillLight.position.set(-10, 10, -10);
                this.scene.add(fillLight);

                // Back light
                const backLight = new THREE.DirectionalLight(0x06b6d4, 0.2);
                backLight.position.set(0, 10, -20);
                this.scene.add(backLight);
            }

            createFloor() {
                // Main floor
                const floorGeom = new THREE.PlaneGeometry(50, 50);
                const floorMat = new THREE.MeshStandardMaterial({
                    color: COLORS.floor,
                    metalness: 0.1,
                    roughness: 0.9
                });
                const floor = new THREE.Mesh(floorGeom, floorMat);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);

                // Grid overlay
                const gridHelper = new THREE.GridHelper(50, 50, COLORS.grid, COLORS.grid);
                gridHelper.material.opacity = 0.3;
                gridHelper.material.transparent = true;
                this.scene.add(gridHelper);
            }

            onResize() {
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 15;
                this.camera.left = -frustumSize * aspect;
                this.camera.right = frustumSize * aspect;
                this.camera.top = frustumSize;
                this.camera.bottom = -frustumSize;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            onClick(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);

                if (intersects.length > 0) {
                    let obj = intersects[0].object;
                    // Traverse up to find station or work item
                    while (obj.parent && !obj.userData.type) {
                        obj = obj.parent;
                    }
                    if (obj.userData.type === 'station' || obj.userData.type === 'workItem') {
                        this.selectObject(obj);
                    }
                }
            }

            selectObject(obj) {
                this.selectedObject = obj;
                const event = new CustomEvent('object-selected', { detail: obj.userData });
                window.dispatchEvent(event);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();

                // Update animations
                const time = performance.now() * 0.001;
                this.stations.forEach(station => station.update(time));
                this.workItems.forEach(item => item.update(time));

                this.renderer.render(this.scene, this.camera);
            }

            resetView() {
                this.camera.position.set(20, 20, 20);
                this.camera.lookAt(0, 0, 0);
                this.controls.reset();
            }

            clear() {
                this.stations.forEach(station => {
                    this.scene.remove(station.group);
                });
                this.stations.clear();

                this.conveyors.forEach(conveyor => {
                    this.scene.remove(conveyor.mesh);
                });
                this.conveyors = [];

                this.workItems.forEach(item => {
                    this.scene.remove(item.group);
                });
                this.workItems = [];
            }

            addStation(id, type, position) {
                const station = new Station(id, type, position);
                this.stations.set(id, station);
                this.scene.add(station.group);
                return station;
            }

            addConveyor(fromId, toId) {
                const fromStation = this.stations.get(fromId);
                const toStation = this.stations.get(toId);
                if (fromStation && toStation) {
                    const conveyor = new Conveyor(fromStation.position, toStation.position, fromId, toId);
                    this.conveyors.push(conveyor);
                    this.scene.add(conveyor.mesh);
                    return conveyor;
                }
                return null;
            }

            addWorkItem(data, position) {
                const item = new WorkItem(data, position);
                this.workItems.push(item);
                this.scene.add(item.group);
                return item;
            }

            removeWorkItem(item) {
                const index = this.workItems.indexOf(item);
                if (index > -1) {
                    this.workItems.splice(index, 1);
                    this.scene.remove(item.group);
                }
            }
        }

        // ============================================
        // STATION CLASS
        // ============================================
        class Station {
            constructor(id, type, position) {
                this.id = id;
                this.type = type;
                this.position = position;
                this.status = 'idle';
                this.data = {
                    toolsUsed: [],
                    tokensIn: 0,
                    tokensOut: 0,
                    startTime: null,
                    endTime: null
                };

                this.group = new THREE.Group();
                this.group.position.copy(position);
                this.group.userData = { type: 'station', id, agentType: type, station: this };

                this.createMesh();
            }

            createMesh() {
                const color = AGENT_TYPE_COLORS[this.type] || COLORS.default;

                // Base platform (hexagonal)
                const baseGeom = new THREE.CylinderGeometry(1.2, 1.3, 0.2, 6);
                const baseMat = new THREE.MeshStandardMaterial({
                    color: color,
                    metalness: 0.3,
                    roughness: 0.7
                });
                this.base = new THREE.Mesh(baseGeom, baseMat);
                this.base.position.y = 0.1;
                this.base.castShadow = true;
                this.base.receiveShadow = true;
                this.group.add(this.base);

                // Main body
                const bodyGeom = new THREE.BoxGeometry(1.6, 1.2, 1.6);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x1e293b,
                    metalness: 0.2,
                    roughness: 0.8
                });
                this.body = new THREE.Mesh(bodyGeom, bodyMat);
                this.body.position.y = 0.8;
                this.body.castShadow = true;
                this.group.add(this.body);

                // Status ring
                const ringGeom = new THREE.TorusGeometry(0.9, 0.08, 8, 32);
                this.ringMat = new THREE.MeshStandardMaterial({
                    color: COLORS.idle,
                    emissive: COLORS.idle,
                    emissiveIntensity: 0.3
                });
                this.ring = new THREE.Mesh(ringGeom, this.ringMat);
                this.ring.rotation.x = Math.PI / 2;
                this.ring.position.y = 1.5;
                this.group.add(this.ring);

                // Label
                this.createLabel();
            }

            createLabel() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#e0e0e0';
                ctx.font = 'bold 24px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.id.substring(0, 12), 128, 40);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.scale.set(2, 0.5, 1);
                sprite.position.y = 2.2;
                this.group.add(sprite);
            }

            setStatus(status) {
                this.status = status;
                const statusColors = {
                    idle: COLORS.idle,
                    working: COLORS.working,
                    complete: COLORS.complete,
                    error: COLORS.error
                };
                const color = statusColors[status] || COLORS.idle;
                this.ringMat.color.setHex(color);
                this.ringMat.emissive.setHex(color);
                this.ringMat.emissiveIntensity = status === 'working' ? 0.8 : 0.3;
            }

            update(time) {
                if (this.status === 'working') {
                    this.ring.rotation.z = time * 2;
                    this.ringMat.emissiveIntensity = 0.5 + Math.sin(time * 4) * 0.3;
                } else if (this.status === 'complete') {
                    this.ringMat.emissiveIntensity = 0.3 + Math.sin(time * 6) * 0.2;
                } else if (this.status === 'error') {
                    this.ringMat.emissiveIntensity = 0.3 + Math.sin(time * 8) * 0.4;
                    // Shake effect
                    this.group.position.x = this.position.x + Math.sin(time * 20) * 0.02;
                } else {
                    this.group.position.x = this.position.x;
                }
            }

            addTool(toolName) {
                if (!this.data.toolsUsed.includes(toolName)) {
                    this.data.toolsUsed.push(toolName);
                }
            }

            addTokens(input, output) {
                this.data.tokensIn += input || 0;
                this.data.tokensOut += output || 0;
            }
        }

        // ============================================
        // CONVEYOR CLASS
        // ============================================
        class Conveyor {
            constructor(fromPos, toPos, fromId, toId) {
                this.fromId = fromId;
                this.toId = toId;
                this.fromPos = fromPos;
                this.toPos = toPos;

                const direction = new THREE.Vector3().subVectors(toPos, fromPos);
                const length = direction.length() - 2.5; // Account for station sizes
                const midPoint = new THREE.Vector3().addVectors(fromPos, toPos).multiplyScalar(0.5);

                const geom = new THREE.BoxGeometry(0.4, 0.1, length);
                const mat = new THREE.MeshStandardMaterial({
                    color: COLORS.conveyor,
                    metalness: 0.4,
                    roughness: 0.6
                });
                this.mesh = new THREE.Mesh(geom, mat);
                this.mesh.position.copy(midPoint);
                this.mesh.position.y = 0.3;
                this.mesh.lookAt(toPos.x, 0.3, toPos.z);
                this.mesh.rotateY(Math.PI / 2);
                this.mesh.castShadow = true;
            }
        }

        // ============================================
        // WORK ITEM CLASS
        // ============================================
        class WorkItem {
            constructor(data, position) {
                this.data = data;
                this.startPos = position.clone();
                this.endPos = null;
                this.progress = 0;
                this.active = true;

                this.group = new THREE.Group();
                this.group.position.copy(position);
                this.group.userData = { type: 'workItem', data, workItem: this };

                this.createMesh();
            }

            createMesh() {
                // Document/data cube
                const geom = new THREE.BoxGeometry(0.3, 0.05, 0.4);
                const mat = new THREE.MeshStandardMaterial({
                    color: COLORS.workItem,
                    emissive: COLORS.workItem,
                    emissiveIntensity: 0.5
                });
                this.mesh = new THREE.Mesh(geom, mat);
                this.mesh.castShadow = true;
                this.group.add(this.mesh);
            }

            setPath(endPos) {
                this.endPos = endPos;
            }

            update(time) {
                if (this.endPos && this.progress < 1) {
                    this.progress += 0.01;
                    this.group.position.lerpVectors(this.startPos, this.endPos, this.progress);
                    this.group.position.y = 0.5 + Math.sin(this.progress * Math.PI) * 0.3;
                }
                // Gentle bob
                this.mesh.position.y = Math.sin(time * 3) * 0.02;
            }
        }

        // ============================================
        // TRANSCRIPT PARSER
        // ============================================
        class TranscriptParser {
            constructor() {
                this.events = [];
                this.agents = new Map();
                this.delegations = [];
                this.totalTokens = { input: 0, output: 0 };
            }

            async loadFiles(files) {
                this.events = [];
                this.agents.clear();
                this.delegations = [];
                this.totalTokens = { input: 0, output: 0 };

                for (const file of files) {
                    const content = await file.text();
                    this.parseContent(content, file.name);
                }

                // Sort events by timestamp
                this.events.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                return {
                    events: this.events,
                    agents: this.agents,
                    delegations: this.delegations,
                    totalTokens: this.totalTokens
                };
            }

            parseContent(content, filename) {
                const lines = content.trim().split('\n');

                for (const line of lines) {
                    if (!line.trim()) continue;
                    try {
                        const entry = JSON.parse(line);
                        this.parseEntry(entry, filename);
                    } catch (e) {
                        // Skip invalid JSON lines
                    }
                }
            }

            parseEntry(entry, filename) {
                const { type, timestamp, message, uuid, sessionId, agentId, parentToolUseID } = entry;

                // Determine agent ID
                const currentAgentId = agentId || sessionId || 'main';

                if (!this.agents.has(currentAgentId)) {
                    this.agents.set(currentAgentId, {
                        id: currentAgentId,
                        type: this.inferAgentType(currentAgentId, entry),
                        parentId: null,
                        events: []
                    });
                }

                // Track delegations
                if (parentToolUseID && agentId) {
                    this.delegations.push({
                        parentId: 'main',
                        childId: agentId,
                        toolUseId: parentToolUseID
                    });
                    const agent = this.agents.get(currentAgentId);
                    if (agent) agent.parentId = 'main';
                }

                // Parse based on entry type
                if (type === 'tool_use' || (message?.content && Array.isArray(message.content))) {
                    const content = message?.content || [];
                    for (const block of content) {
                        if (block.type === 'tool_use') {
                            this.events.push({
                                type: 'tool_start',
                                timestamp: timestamp || new Date().toISOString(),
                                agentId: currentAgentId,
                                toolName: block.name,
                                toolUseId: block.id,
                                input: block.input
                            });
                        }
                        if (block.type === 'tool_result') {
                            this.events.push({
                                type: 'tool_end',
                                timestamp: timestamp || new Date().toISOString(),
                                agentId: currentAgentId,
                                toolUseId: block.tool_use_id,
                                isError: block.is_error
                            });
                        }
                    }
                }

                // Track token usage
                if (message?.usage) {
                    const { input_tokens, output_tokens } = message.usage;
                    this.totalTokens.input += input_tokens || 0;
                    this.totalTokens.output += output_tokens || 0;

                    this.events.push({
                        type: 'tokens',
                        timestamp: timestamp || new Date().toISOString(),
                        agentId: currentAgentId,
                        inputTokens: input_tokens || 0,
                        outputTokens: output_tokens || 0
                    });
                }

                // Track agent progress
                if (type === 'agent_progress' || type === 'progress') {
                    this.events.push({
                        type: 'progress',
                        timestamp: timestamp || new Date().toISOString(),
                        agentId: currentAgentId,
                        data: entry
                    });
                }
            }

            inferAgentType(agentId, entry) {
                const id = agentId.toLowerCase();
                if (id.includes('explore')) return 'Explore';
                if (id.includes('plan')) return 'Plan';
                if (id.includes('bash')) return 'Bash';
                if (id.includes('research')) return 'researcher';
                if (id.includes('write') || id.includes('edit')) return 'writer';
                if (id.includes('valid') || id.includes('test')) return 'validator';
                if (id === 'main') return 'orchestrator';
                return 'general-purpose';
            }

            getEvents() {
                return this.events;
            }

            getAgents() {
                return this.agents;
            }

            getDelegations() {
                return this.delegations;
            }
        }

        // ============================================
        // FACTORY LAYOUT
        // ============================================
        class FactoryLayout {
            constructor(scene) {
                this.scene = scene;
            }

            buildFromData(agents, delegations) {
                this.scene.clear();

                // Create main orchestrator at center
                const mainStation = this.scene.addStation('main', 'orchestrator', new THREE.Vector3(0, 0, 0));

                // Position subagents in circle around main
                const subagents = Array.from(agents.values()).filter(a => a.id !== 'main');
                const radius = 6;
                const angleStep = (2 * Math.PI) / Math.max(subagents.length, 1);

                subagents.forEach((agent, i) => {
                    const angle = i * angleStep - Math.PI / 2;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const station = this.scene.addStation(agent.id, agent.type, new THREE.Vector3(x, 0, z));

                    // Create conveyor from main to this agent
                    this.scene.addConveyor('main', agent.id);
                });

                return mainStation;
            }
        }

        // ============================================
        // TIMELINE CONTROLLER
        // ============================================
        class TimelineController {
            constructor() {
                this.events = [];
                this.currentIndex = 0;
                this.isPlaying = false;
                this.speed = 1;
                this.lastUpdate = 0;
                this.baseInterval = 500; // ms between events at 1x speed

                this.slider = document.getElementById('timeline-slider');
                this.playBtn = document.getElementById('play-btn');
                this.playIcon = document.getElementById('play-icon');
                this.pauseIcon = document.getElementById('pause-icon');
                this.currentTimeEl = document.getElementById('current-time');
                this.totalTimeEl = document.getElementById('total-time');
                this.speedSelect = document.getElementById('speed-select');
                this.timeline = document.getElementById('timeline');

                this.setupEventListeners();
            }

            setupEventListeners() {
                this.playBtn.addEventListener('click', () => this.togglePlay());
                this.slider.addEventListener('input', (e) => this.seekTo(parseInt(e.target.value)));
                this.speedSelect.addEventListener('change', (e) => {
                    this.speed = parseFloat(e.target.value);
                });
            }

            setEvents(events) {
                this.events = events;
                this.currentIndex = 0;
                this.slider.max = Math.max(events.length - 1, 0);
                this.slider.value = 0;
                this.updateTimeDisplay();
                this.timeline.classList.remove('hidden');
            }

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                this.playIcon.style.display = this.isPlaying ? 'none' : 'block';
                this.pauseIcon.style.display = this.isPlaying ? 'block' : 'none';
                if (this.isPlaying) {
                    this.lastUpdate = performance.now();
                    this.play();
                }
            }

            play() {
                if (!this.isPlaying) return;

                const now = performance.now();
                const elapsed = now - this.lastUpdate;
                const interval = this.baseInterval / this.speed;

                if (elapsed >= interval) {
                    this.lastUpdate = now;
                    if (this.currentIndex < this.events.length - 1) {
                        this.currentIndex++;
                        this.slider.value = this.currentIndex;
                        this.updateTimeDisplay();
                        this.emitEvent(this.events[this.currentIndex]);
                    } else {
                        this.isPlaying = false;
                        this.playIcon.style.display = 'block';
                        this.pauseIcon.style.display = 'none';
                    }
                }

                requestAnimationFrame(() => this.play());
            }

            seekTo(index) {
                // Reset and replay up to index
                window.dispatchEvent(new CustomEvent('timeline-reset'));

                this.currentIndex = 0;
                for (let i = 0; i <= index && i < this.events.length; i++) {
                    this.emitEvent(this.events[i]);
                    this.currentIndex = i;
                }
                this.updateTimeDisplay();
            }

            emitEvent(event) {
                window.dispatchEvent(new CustomEvent('timeline-event', { detail: event }));
            }

            updateTimeDisplay() {
                const formatTime = (idx) => {
                    const mins = Math.floor(idx / 60);
                    const secs = idx % 60;
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                };
                this.currentTimeEl.textContent = formatTime(this.currentIndex);
                this.totalTimeEl.textContent = formatTime(this.events.length);
            }

            hide() {
                this.timeline.classList.add('hidden');
            }
        }

        // ============================================
        // UI PANEL CONTROLLER
        // ============================================
        class UIPanelController {
            constructor() {
                this.panel = document.getElementById('info-panel');
                this.title = document.getElementById('panel-title');
                this.subtitle = document.getElementById('panel-subtitle');
                this.content = document.getElementById('panel-content');
                this.closeBtn = document.getElementById('panel-close');

                this.closeBtn.addEventListener('click', () => this.hide());
            }

            showStation(station) {
                this.title.textContent = station.id === 'main' ? 'Main Orchestrator' : `Agent: ${station.id.substring(0, 20)}`;
                this.subtitle.textContent = station.type;

                const statusClass = `status-${station.status}`;
                const duration = station.data.startTime && station.data.endTime
                    ? ((new Date(station.data.endTime) - new Date(station.data.startTime)) / 1000).toFixed(1) + 's'
                    : 'Active';

                this.content.innerHTML = `
                    <div class="panel-section">
                        <div class="panel-section-title">Status</div>
                        <span class="status-badge ${statusClass}">${station.status}</span>
                    </div>
                    <div class="panel-section">
                        <div class="panel-section-title">Statistics</div>
                        <div class="panel-stat">
                            <span class="panel-stat-label">Duration</span>
                            <span class="panel-stat-value">${duration}</span>
                        </div>
                        <div class="panel-stat">
                            <span class="panel-stat-label">Tokens In</span>
                            <span class="panel-stat-value">${station.data.tokensIn.toLocaleString()}</span>
                        </div>
                        <div class="panel-stat">
                            <span class="panel-stat-label">Tokens Out</span>
                            <span class="panel-stat-value">${station.data.tokensOut.toLocaleString()}</span>
                        </div>
                    </div>
                    <div class="panel-section">
                        <div class="panel-section-title">Tools Used (${station.data.toolsUsed.length})</div>
                        <div class="tool-list">
                            ${station.data.toolsUsed.slice(0, 10).map(t => `<div class="tool-item">${t}</div>`).join('')}
                            ${station.data.toolsUsed.length > 10 ? `<div class="tool-item">... and ${station.data.toolsUsed.length - 10} more</div>` : ''}
                        </div>
                    </div>
                `;
                this.show();
            }

            showWorkItem(item) {
                this.title.textContent = 'Work Item';
                this.subtitle.textContent = item.data.type || 'Data';

                this.content.innerHTML = `
                    <div class="panel-section">
                        <div class="panel-section-title">Data Preview</div>
                        <div class="json-preview">
                            <pre>${JSON.stringify(item.data, null, 2).substring(0, 500)}</pre>
                        </div>
                    </div>
                `;
                this.show();
            }

            show() {
                this.panel.classList.add('visible');
            }

            hide() {
                this.panel.classList.remove('visible');
            }
        }

        // ============================================
        // REAL-TIME EVENT STREAM
        // ============================================
        class EventStream {
            constructor(url = 'http://localhost:3003/events') {
                this.url = url;
                this.offset = 0;
                this.polling = false;
                this.pollInterval = 1000;
            }

            start(callback) {
                this.polling = true;
                this.callback = callback;
                this.poll();
            }

            stop() {
                this.polling = false;
            }

            async poll() {
                if (!this.polling) return;

                try {
                    const response = await fetch(`${this.url}?offset=${this.offset}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.events && data.events.length > 0) {
                            data.events.forEach(event => {
                                if (this.callback) this.callback(event);
                            });
                            this.offset = data.offset;
                        }
                    }
                } catch (e) {
                    // Server not available, silent fail
                }

                setTimeout(() => this.poll(), this.pollInterval);
            }
        }

        // ============================================
        // MAIN APPLICATION
        // ============================================
        class FactoryFloorApp {
            constructor() {
                this.scene = new FactoryScene(document.getElementById('canvas-container'));
                this.parser = new TranscriptParser();
                this.layout = new FactoryLayout(this.scene);
                this.timeline = new TimelineController();
                this.uiPanel = new UIPanelController();
                this.eventStream = new EventStream();
                this.mode = 'historical';

                this.setupEventListeners();
                this.updateStats(0, 0, 0);
            }

            setupEventListeners() {
                // File input
                const fileInput = document.getElementById('file-input');
                const loadBtn = document.getElementById('load-btn');
                const welcomeLoadBtn = document.getElementById('welcome-load-btn');

                loadBtn.addEventListener('click', () => fileInput.click());
                welcomeLoadBtn.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.loadFiles(e.target.files));

                // Reset view
                document.getElementById('reset-btn').addEventListener('click', () => this.scene.resetView());

                // Mode toggle
                document.getElementById('mode-historical').addEventListener('click', () => this.setMode('historical'));
                document.getElementById('mode-realtime').addEventListener('click', () => this.setMode('realtime'));

                // Object selection
                window.addEventListener('object-selected', (e) => this.onObjectSelected(e.detail));

                // Timeline events
                window.addEventListener('timeline-event', (e) => this.processEvent(e.detail));
                window.addEventListener('timeline-reset', () => this.resetStations());
            }

            async loadFiles(files) {
                if (files.length === 0) return;

                document.getElementById('welcome').style.display = 'none';

                const data = await this.parser.loadFiles(files);

                // Build layout
                this.layout.buildFromData(data.agents, data.delegations);

                // Setup timeline
                this.timeline.setEvents(data.events);

                // Update stats
                this.updateStats(
                    data.agents.size,
                    data.events.length,
                    data.totalTokens.input + data.totalTokens.output
                );

                // Process all events initially
                this.resetStations();
                data.events.forEach(event => this.processEvent(event));
            }

            setMode(mode) {
                this.mode = mode;
                document.getElementById('mode-historical').classList.toggle('active', mode === 'historical');
                document.getElementById('mode-realtime').classList.toggle('active', mode === 'realtime');
                document.getElementById('realtime-indicator').classList.toggle('active', mode === 'realtime');

                if (mode === 'realtime') {
                    this.timeline.hide();
                    this.scene.clear();
                    this.layout.buildFromData(new Map([['main', { id: 'main', type: 'orchestrator' }]]), []);
                    this.eventStream.start((event) => this.processRealtimeEvent(event));
                } else {
                    this.eventStream.stop();
                }
            }

            processEvent(event) {
                const station = this.scene.stations.get(event.agentId);
                if (!station) return;

                switch (event.type) {
                    case 'tool_start':
                        station.setStatus('working');
                        station.addTool(event.toolName);
                        if (!station.data.startTime) {
                            station.data.startTime = event.timestamp;
                        }
                        break;
                    case 'tool_end':
                        if (event.isError) {
                            station.setStatus('error');
                        } else {
                            station.setStatus('complete');
                            setTimeout(() => {
                                if (station.status === 'complete') {
                                    station.setStatus('idle');
                                }
                            }, 1000);
                        }
                        station.data.endTime = event.timestamp;
                        break;
                    case 'tokens':
                        station.addTokens(event.inputTokens, event.outputTokens);
                        break;
                }
            }

            processRealtimeEvent(event) {
                // Check if this is a new agent
                if (event.agentId && !this.scene.stations.has(event.agentId)) {
                    // Add new station dynamically
                    const existingCount = this.scene.stations.size;
                    const angle = existingCount * (Math.PI / 4);
                    const radius = 6;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    this.scene.addStation(event.agentId, event.agentType || 'general-purpose', new THREE.Vector3(x, 0, z));
                    this.scene.addConveyor('main', event.agentId);
                }

                this.processEvent(event);
                this.updateStats(
                    this.scene.stations.size,
                    this.parser.events.length + 1,
                    this.parser.totalTokens.input + this.parser.totalTokens.output
                );
            }

            resetStations() {
                this.scene.stations.forEach(station => {
                    station.setStatus('idle');
                    station.data.toolsUsed = [];
                    station.data.tokensIn = 0;
                    station.data.tokensOut = 0;
                    station.data.startTime = null;
                    station.data.endTime = null;
                });
            }

            onObjectSelected(userData) {
                if (userData.type === 'station') {
                    this.uiPanel.showStation(userData.station);
                } else if (userData.type === 'workItem') {
                    this.uiPanel.showWorkItem(userData.workItem);
                }
            }

            updateStats(agents, events, tokens) {
                document.getElementById('stat-agents').textContent = agents;
                document.getElementById('stat-events').textContent = events;
                document.getElementById('stat-tokens').textContent = tokens.toLocaleString();
            }
        }

        // Initialize application
        const app = new FactoryFloorApp();
    </script>
</body>
</html>
