<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{CLIENT_NAME}} Interactive Content Planning Dashboard</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <style>
        /* CACHE BUSTER - v20250827-0001 - CALENDAR CLICK AREA FIX */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            /* Modern Color Palette */
            --primary-green: #10b981;
            --primary-green-dark: #059669;
            --primary-green-light: #d1fae5;
            
            /* Content Type Colors */
            --blog-post: #8b5cf6;      /* Purple for Blog Posts */
            --social-media: #f59e0b;   /* Amber for Social Media */
            --location-page: #06b6d4;  /* Cyan for Location Pages */
            --email: #ef4444;          /* Red for Email */
            --video: #ec4899;          /* Pink for Video */
            
            /* Priority Colors (secondary) */
            --priority-high: #dc2626;
            --priority-medium: #d97706;
            --priority-low: #16a34a;
            
            /* Generation Type Colors */
            --gen-local: #8b5cf6;      /* Purple for Local */
            --gen-systematic: #06b6d4;  /* Cyan for Systematic */
            
            /* Neutral Colors */
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
            
            /* Collapsible Section Variables */
            --collapsible-bg: rgba(255, 255, 255, 0.9);
            --collapsible-border: rgba(255, 255, 255, 0.3);
            --collapsible-header-bg: rgba(248, 249, 250, 0.8);
            --collapsible-transition: all 0.3s ease-in-out;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            
            /* Typography */
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
        }
        
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        
        body {
            font-family: var(--font-sans);
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            color: var(--gray-800);
            line-height: 1.6;
            font-weight: 400;
        }
        
        /* CSS GRID LAYOUT - FORCES CONSISTENT SECTION WIDTH - v2401 */
        .dashboard {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 16px;
            align-items: start;
        }

        /* NEW SIDE-BY-SIDE PLANNING WORKSPACE */
        .planning-workspace {
            display: block;
            min-height: auto;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            overflow: hidden;
        }

        /* CONTENT STAGING AREA (FULL WIDTH) */
        .planning-sidebar {
            background: rgba(248, 249, 250, 0.9);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--gray-200);
            background: rgba(255, 255, 255, 0.9);
        }

        .sidebar-title {
            margin: 0 0 8px 0;
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--gray-800);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .workflow-status {
            font-size: 0.875rem;
            color: var(--gray-600);
            margin: 0;
        }

        .sidebar-controls {
            padding: 12px 16px;
            border-bottom: 1px solid var(--gray-200);
            background: rgba(248, 249, 250, 0.8);
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .cards-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        /* CALENDAR AREA (RIGHT 65%) */




        /* RESPONSIVE DESIGN */
        @media (max-width: 1200px) {
            .planning-workspace {
                /* Full width layout maintained */
            }
        }

        @media (max-width: 900px) {
            .planning-workspace {
                /* Full width layout maintained */
            }
            
            .planning-sidebar {
                max-height: none;
            }
        }

        /* CONTENT CARD SYSTEM - IMPROVED DESIGN */
        .content-card {
            background: white;
            border: 1px solid var(--gray-200);
            border-radius: 12px;
            padding: 0;
            margin-bottom: 16px;
            box-shadow: var(--shadow-sm);
            transition: all 0.2s ease;
            cursor: grab;
            position: relative;
            overflow: hidden;
        }

        .content-card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .content-card.selected {
            border-color: var(--primary-green);
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
        }

        .content-card.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
            cursor: grabbing;
        }

        /* Submitted state styling */
        .content-card.submitted {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border-color: #86efac;
            opacity: 0.8;
            position: relative;
        }

        .content-card.submitted::before {
            content: '✅ SUBMITTED';
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--success-green);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            z-index: 10;
        }

        .content-card.submitted:hover {
            transform: none;
            cursor: not-allowed;
        }

        .content-card.submitted input[type="checkbox"] {
            pointer-events: none;
            opacity: 0.5;
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px 0 20px;
            margin-bottom: 0;
        }

        .card-checkbox {
            margin: 2px 8px 0 0;
            cursor: pointer;
        }

        .card-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .status-staged {
            color: #8b5cf6;
        }

        .status-ready {
            color: #10b981;
        }

        .status-committed {
            color: #06b6d4;
        }

        .card-description {
            font-size: 1rem;
            line-height: 1.5;
            color: var(--gray-900);
            margin-bottom: 0;
            font-weight: 600;
            padding: 12px 20px;
            border-bottom: 1px solid var(--gray-100);
        }

        .card-badges {
            display: flex;
            gap: 8px;
            padding: 16px 20px 12px 20px;
        }

        .card-meta {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px 12px;
            padding: 0 20px 16px 20px;
            background: var(--gray-25);
        }

        .meta-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .meta-label {
            font-size: 0.6875rem;
            text-transform: uppercase;
            font-weight: 700;
            color: var(--gray-500);
            letter-spacing: 0.5px;
        }

        .meta-value {
            font-size: 0.875rem;
            color: var(--gray-800);
            font-weight: 600;
            line-height: 1.2;
        }

        .content-type-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border: 1px solid transparent;
        }

        .content-type-blog {
            background: linear-gradient(135deg, #dbeafe, #bfdbfe);
            color: #1e40af;
            border-color: #93c5fd;
        }

        .content-type-social {
            background: linear-gradient(135deg, #fce7f3, #f9a8d4);
            color: #be185d;
            border-color: #f472b6;
        }

        .content-type-location {
            background: linear-gradient(135deg, #dcfce7, #bbf7d0);
            color: #16a34a;
            border-color: #86efac;
        }

        .content-type-email {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            color: #d97706;
            border-color: #facc15;
        }

        .content-type-video {
            background: linear-gradient(135deg, #f3e8ff, #ddd6fe);
            color: #7c3aed;
            border-color: #c4b5fd;
        }

        .priority-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border: 1px solid transparent;
        }

        .priority-high {
            background: linear-gradient(135deg, #fee2e2, #fecaca);
            color: #dc2626;
            border-color: #f87171;
        }

        .priority-medium {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            color: #d97706;
            border-color: #facc15;
        }

        .priority-low {
            background: linear-gradient(135deg, #f3f4f6, #e5e7eb);
            color: #6b7280;
            border-color: #d1d5db;
        }

        .generation-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border: 1px solid transparent;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .generation-local {
            background: linear-gradient(135deg, #f3e8ff, #ddd6fe);
            color: #7c3aed;
            border-color: #c4b5fd;
        }

        .generation-systematic {
            background: linear-gradient(135deg, #cffafe, #a5f3fc);
            color: #0891b2;
            border-color: #67e8f9;
        }

        /* NEW: Generation Status Badge Styles */
        .generation-status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border: 1px solid transparent;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .gen-pending {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            color: #d97706;
            border-color: #f59e0b;
        }

        .gen-complete {
            background: linear-gradient(135deg, #d1fae5, #a7f3d0);
            color: #059669;
            border-color: #10b981;
        }

        .gen-systematic {
            background: linear-gradient(135deg, #e0f2fe, #bae6fd);
            color: #0284c7;
            border-color: #0ea5e9;
        }

        .gen-failed {
            background: linear-gradient(135deg, #fee2e2, #fecaca);
            color: #dc2626;
            border-color: #ef4444;
        }

        /* NEW: Content Preview Section Styles */
        .content-preview-section {
            margin: 16px 20px;
            padding: 16px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }

        .content-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .preview-label {
            font-weight: 600;
            color: #374151;
            font-size: 0.875rem;
        }

        .preview-expand-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .preview-expand-btn:hover {
            background: #059669;
        }

        .content-preview-text {
            color: #4b5563;
            font-size: 0.875rem;
            line-height: 1.5;
            font-style: italic;
            border-left: 3px solid #10b981;
            padding-left: 12px;
        }

        .card-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: var(--gray-50);
            border-top: 1px solid var(--gray-100);
        }

        .card-edit-btn {
            padding: 6px 12px;
            border: 1px solid var(--gray-300);
            border-radius: 6px;
            background: white;
            color: var(--gray-600);
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .card-edit-btn:hover {
            background: var(--gray-50);
            border-color: var(--gray-400);
            color: var(--gray-700);
            transform: translateY(-1px);
        }

        .card-drag-handle {
            color: var(--gray-400);
            font-size: 1rem;
            padding: 4px;
            cursor: grab;
        }

        .card-drag-handle:hover {
            color: var(--gray-600);
        }

        /* WORKFLOW STATUS INDICATORS */
        .workflow-steps {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            border: 1px solid var(--gray-200);
        }

        .workflow-step {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--gray-600);
            position: relative;
        }

        .workflow-step:not(:last-child)::after {
            content: '→';
            margin-left: 8px;
            color: var(--gray-400);
        }

        .workflow-step.active {
            color: var(--primary-green);
            font-weight: 600;
        }

        /* COMMIT BUTTON STYLING */
        .commit-button {
            background: var(--primary-green);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .commit-button:hover {
            background: var(--primary-green-dark);
            transform: translateY(-1px);
        }

        .commit-button:disabled {
            background: var(--gray-300);
            color: var(--gray-500);
            cursor: not-allowed;
            transform: none;
        }

        /* EMPTY STATE FOR CARDS */
        .cards-empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--gray-500);
        }

        .cards-empty-state .icon {
            font-size: 2rem;
            margin-bottom: 12px;
        }

        .cards-empty-state h4 {
            margin: 0 0 8px 0;
            font-size: 1rem;
            color: var(--gray-700);
        }

        .cards-empty-state p {
            margin: 0;
            font-size: 0.875rem;
        }
        
        /* ENFORCE GRID ALIGNMENT FOR ALL SECTIONS */
        .dashboard > * {
            grid-column: 1;
            width: 100% !important;
            max-width: 100% !important;
            min-width: 100% !important;
            box-sizing: border-box !important;
        }
        
        .header {
            background: linear-gradient(135deg, var(--primary-green) 0%, var(--primary-green-dark) 100%);
            color: white;
            padding: 20px 28px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-md);
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: -10px;
            right: -10px;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(255,255,255,0.06) 0%, transparent 70%);
            border-radius: 50%;
        }
        
        .header-content {
            position: relative;
            z-index: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }
        
        .header-main {
            flex: 1;
            min-width: 280px;
        }
        
        .header h1 {
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 2px;
            letter-spacing: -0.02em;
            color: white;
        }
        
        .header-subtitle {
            font-size: 0.875rem;
            font-weight: 400;
            opacity: 0.75;
            margin-bottom: 0;
        }
        
        .sync-status {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(8px);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.15);
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
            font-size: 0.8rem;
        }
        
        .sync-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-weight: 500;
        }
        
        .sync-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .sync-dot.connected { 
            background: #22c55e;
            box-shadow: 0 0 4px rgba(34, 197, 94, 0.3);
        }
        .sync-dot.disconnected { 
            background: #ef4444;
            box-shadow: 0 0 4px rgba(239, 68, 68, 0.3);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .planning-section {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: var(--shadow);
            transition: all 0.2s ease;
        }
        
        .planning-section:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }
        
        .planning-section h2 {
            color: var(--gray-800);
            margin-bottom: 16px;
            font-size: 1.25rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .voice-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }
        
        .voice-btn, .control-btn, .action-btn {
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.15s ease;
            border: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-family: var(--font-sans);
            letter-spacing: -0.01em;
        }
        
        .voice-btn {
            background: var(--primary-green-light);
            color: var(--primary-green-dark);
            border: 1px solid var(--primary-green);
        }
        
        .voice-btn:hover {
            background: var(--primary-green);
            color: white;
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        
        .voice-btn.recording {
            background: #fee2e2;
            color: #dc2626;
            border-color: #ef4444;
            animation: recording-pulse 1.5s infinite;
        }
        
        @keyframes recording-pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.3); }
            50% { transform: scale(1.01); box-shadow: 0 0 0 4px rgba(239, 68, 68, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        
        .text-input {
            width: 100%;
            min-height: 100px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            resize: vertical;
            font-family: inherit;
        }
        
        .text-input:focus {
            outline: none;
            border-color: #4CAF50;
        }
        
        .process-btn {
            background: #2c5530;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 15px;
            transition: background 0.3s ease;
        }
        
        .process-btn:hover {
            background: #3e7b40;
        }
        
        .content-table-container {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            box-shadow: var(--shadow);
            overflow: hidden;
            margin-bottom: 16px;
        }
        
        .content-table-container .table-header {
            padding: 12px 16px;
        }
        
        .content-table-container .table-title {
            font-size: 16px;
            font-weight: 600;
        }
        
        /* Collapsible Section Styles */
        .collapsible-section {
            background: var(--collapsible-bg);
            backdrop-filter: blur(12px);
            border: 1px solid var(--collapsible-border);
            border-radius: 12px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
            overflow: hidden;
            width: 100% !important;
            max-width: 100% !important;
            min-width: 100% !important;
            box-sizing: border-box !important;
            grid-column: 1 !important;
        }
        
        .collapsible-header {
            background: var(--collapsible-header-bg);
            backdrop-filter: blur(8px);
            padding: 16px 20px;
            border-bottom: 1px solid var(--gray-200);
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--collapsible-transition);
        }
        
        .collapsible-header:hover {
            background: rgba(240, 242, 247, 0.9);
        }
        
        .collapsible-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--gray-800);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .collapsible-arrow {
            font-size: 14px;
            color: var(--gray-600);
            transition: var(--collapsible-transition);
            transform: rotate(0deg);
        }
        
        .collapsible-section.collapsed .collapsible-arrow {
            transform: rotate(-90deg);
        }
        
        .collapsible-content {
            max-height: 2000px;
            overflow: visible;
            transition: all 0.3s ease-in-out;
            opacity: 1;
        }
        
        .collapsible-section.collapsed .collapsible-content {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
        }

        .collapsible-section.collapsed {
            margin-bottom: 20px !important;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%) !important;
            border-radius: 12px !important;
            width: 100% !important;
            max-width: 100% !important;
            min-width: 100% !important;
            box-sizing: border-box !important;
            border: 1px solid var(--collapsible-border) !important;
            grid-column: 1 !important;
        }
        
        
        /* Analytics Dashboard Styles */
        .analytics-content {
            padding: 20px;
        }
        
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            border: 1px solid var(--gray-200);
            border-radius: 12px;
            padding: 20px;
            box-shadow: var(--shadow);
            position: relative;
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--gray-200);
        }
        
        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--gray-800);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .chart-export {
            background: var(--gray-100);
            border: 1px solid var(--gray-300);
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 12px;
            color: var(--gray-600);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .chart-export:hover {
            background: var(--gray-200);
            color: var(--gray-800);
        }
        
        .chart-canvas {
            position: relative;
            height: 300px;
            width: 100%;
        }
        
        .chart-canvas.small {
            height: 200px;
        }
        
        .chart-canvas.large {
            height: 400px;
        }
        
        .analytics-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-bottom: 30px;
        }
        
        .analytics-stat {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            border: 1px solid var(--gray-200);
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            box-shadow: var(--shadow-sm);
        }
        
        .analytics-stat-number {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary-green);
            margin-bottom: 4px;
        }
        
        .analytics-stat-label {
            font-size: 12px;
            font-weight: 500;
            color: var(--gray-600);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .insights-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            border: 1px solid var(--gray-200);
            border-radius: 12px;
            padding: 20px;
            box-shadow: var(--shadow);
            margin-top: 20px;
        }
        
        .insights-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--gray-800);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .insight-item {
            background: rgba(16, 185, 129, 0.1);
            border-left: 4px solid var(--primary-green);
            padding: 12px 16px;
            margin-bottom: 12px;
            border-radius: 0 8px 8px 0;
        }
        
        .insight-item:last-child {
            margin-bottom: 0;
        }
        
        .insight-text {
            font-size: 14px;
            color: var(--gray-700);
            line-height: 1.5;
        }
        
        .table-header {
            background: rgba(248, 249, 250, 0.8);
            backdrop-filter: blur(8px);
            padding: 16px 20px;
            border-bottom: 1px solid var(--gray-200);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }
        
        .table-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--gray-800);
        }
        
        .table-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .control-btn {
            background: white;
            color: var(--gray-700);
            border: 1px solid var(--gray-200);
            box-shadow: var(--shadow-sm);
        }
        
        .control-btn:hover {
            background: var(--gray-50);
            border-color: var(--gray-300);
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }
        
        .control-btn.active {
            background: var(--primary-green);
            color: white;
            border-color: var(--primary-green);
            box-shadow: var(--shadow-md);
        }
        
        /* Content Type Styled Buttons */
        .control-btn.blog-post {
            background: var(--blog-post);
            color: white;
            border-color: var(--blog-post);
        }
        
        .control-btn.social-media {
            background: var(--social-media);
            color: white;
            border-color: var(--social-media);
        }
        
        .control-btn.location-page {
            background: var(--location-page);
            color: white;
            border-color: var(--location-page);
        }
        
        /* CLEAN TABLE LAYOUT - Reset and force fixed layout */
        .content-table {
            table-layout: fixed !important;
            border-collapse: separate !important;
            border-spacing: 0 !important;
            background: white;
            width: 1460px !important; /* 13-column fixed width equals sum of col widths minus row indicator spacing */
            border: 1px solid var(--gray-200);
            margin: 0 !important;
            padding: 0 !important;
        }
        
        /* Table Headers */
        .content-table th {
            background: var(--gray-50);
            padding: 8px;
            white-space: nowrap;
        }
        
        /* Column widths - forced with important and box-sizing */
        .content-table th:nth-child(1), .content-table td:nth-child(1) { width: 24px !important; min-width: 24px !important; max-width: 24px !important; box-sizing: border-box !important; }
        .content-table th:nth-child(2), .content-table td:nth-child(2) { width: 40px !important; min-width: 40px !important; max-width: 40px !important; box-sizing: border-box !important; }
        .content-table th:nth-child(3), .content-table td:nth-child(3) { width: 280px !important; min-width: 280px !important; max-width: 280px !important; box-sizing: border-box !important; }
        .content-table th:nth-child(4), .content-table td:nth-child(4) { width: 100px !important; min-width: 100px !important; max-width: 100px !important; box-sizing: border-box !important; }
        .content-table th:nth-child(5), .content-table td:nth-child(5) { width: 80px !important; min-width: 80px !important; max-width: 80px !important; box-sizing: border-box !important; }
        .content-table th:nth-child(6), .content-table td:nth-child(6) { width: 120px !important; min-width: 120px !important; max-width: 120px !important; box-sizing: border-box !important; }
        .content-table th:nth-child(7), .content-table td:nth-child(7) { width: 100px !important; min-width: 100px !important; max-width: 100px !important; box-sizing: border-box !important; }
        .content-table th:nth-child(8), .content-table td:nth-child(8) { width: 200px !important; min-width: 200px !important; max-width: 200px !important; box-sizing: border-box !important; }
        .content-table th:nth-child(9), .content-table td:nth-child(9) { width: 80px !important; min-width: 80px !important; max-width: 80px !important; box-sizing: border-box !important; }
        .content-table th:nth-child(10), .content-table td:nth-child(10) { width: 80px !important; min-width: 80px !important; max-width: 80px !important; box-sizing: border-box !important; }
        .content-table th:nth-child(11), .content-table td:nth-child(11) { width: 120px !important; min-width: 120px !important; max-width: 120px !important; box-sizing: border-box !important; }
        .content-table th:nth-child(12), .content-table td:nth-child(12) { width: 120px !important; min-width: 120px !important; max-width: 120px !important; box-sizing: border-box !important; }
        .content-table th:nth-child(13), .content-table td:nth-child(13) { width: 120px !important; min-width: 120px !important; max-width: 120px !important; box-sizing: border-box !important; }
        
        .content-table th {
            text-align: left;
            font-weight: 600;
            color: var(--gray-700);
            border-bottom: 2px solid var(--gray-200);
            border-right: 1px solid var(--gray-200);
            position: sticky;
            top: 0;
            z-index: 10;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Table Data Cells */
        .content-table td {
            padding: 4px !important;
            vertical-align: middle;
            font-size: 12px;
            border-right: 1px solid var(--gray-100);
            border-bottom: 1px solid var(--gray-100);
            overflow: hidden !important;
            text-overflow: ellipsis;
            white-space: nowrap !important;
            box-sizing: border-box !important;
        }
        
        /* Force cell content to respect cell boundaries */
        .content-table td * {
            max-width: 100% !important;
            box-sizing: border-box !important;
        }
        
        /* Additional styling for specific columns */
        .content-table th:nth-child(2), .content-table td:nth-child(2) {
            text-align: center; /* checkbox column */
        }
        
        .content-table th:nth-child(8), .content-table td:nth-child(8) {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Table Row Styling */
        .content-row {
            transition: all 0.2s ease;
            cursor: grab;
            position: relative;
        }
        
        .content-row:hover {
            background: var(--gray-50);
        }
        
        .content-row.selected {
            background: var(--primary-green-light);
        }
        
        /* Content type indicators for table rows */
        .content-row::before {
            display: none;
            content: none;
        }
        
        .content-row.type-blog-post::before {
            background: var(--blog-post);
        }
        
        .content-row.type-social-media::before {
            background: var(--social-media);
        }
        
        .content-row.type-location-page::before {
            background: var(--location-page);
        }
        
        .content-row.type-email::before {
            background: var(--email);
        }
        
        .content-row.type-video::before {
            background: var(--video);
        }
        
        
        
        .row-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        /* Override for standalone editable cells (outside table) */
        .editable-cell {
            border: 1px solid var(--gray-200);
            padding: 8px;
            background: white;
            font-family: inherit;
            font-size: 12px;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        .editable-cell:focus {
            outline: none;
            border-color: var(--primary-green);
            box-shadow: 0 0 0 1px var(--primary-green-light);
        }
        
        .priority-select {
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 14px;
        }
        
        .priority-HIGH { color: #d32f2f; font-weight: 600; }
        .priority-MEDIUM { color: #f57c00; font-weight: 600; }
        .priority-LOW { color: #388e3c; font-weight: 600; }
        
        /* Generation Type Styles */
        .gen-local {
            background: var(--gen-local) !important;
            color: white !important;
            font-weight: 600;
            border-radius: 4px;
            padding: 2px 6px;
        }
        
        .gen-systematic {
            background: var(--gen-systematic) !important;
            color: white !important;
            font-weight: 600;
            border-radius: 4px;
            padding: 2px 6px;
        }
        
        .actions-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
            text-align: center;
        }
        
        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        .action-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
        }
        
        .submit-btn {
            background: #4CAF50;
            color: white;
        }
        
        .submit-btn:hover {
            background: #45a049;
        }
        
        .submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .export-btn {
            background: #2196F3;
            color: white;
        }
        
        .export-btn:hover {
            background: #1976D2;
        }
        
        .clear-btn {
            background: #dc2626;
            color: white;
        }
        
        .clear-btn:hover {
            background: #b91c1c;
        }
        
        .airtable-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: var(--shadow-sm);
            margin-top: 20px;
        }
        
        .airtable-section h2 {
            color: var(--gray-900);
            margin-bottom: 12px;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .airtable-embed {
            transition: all 0.3s ease;
        }
        
        .airtable-embed:hover {
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .tab-navigation {
            display: flex;
            gap: 2px;
            margin-bottom: 16px;
            border-bottom: 1px solid var(--gray-200);
        }
        
        .tab-button {
            background: transparent;
            border: none;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 500;
            color: var(--gray-600);
            cursor: pointer;
            border-radius: 6px 6px 0 0;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .tab-button:hover {
            background: #f8f9fa;
            color: #2c5530;
        }
        
        .tab-button.active {
            background: #2c5530;
            color: white;
            border-bottom: 3px solid #4CAF50;
        }
        
        .tab-content {
            position: relative;
        }
        
        .tab-pane {
            display: none;
        }
        
        .tab-pane.active {
            display: block;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }


        .status-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
        }
        
        .status-log {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #2c5530;
        }
        
        .stat-label {
            color: #666;
            margin-top: 5px;
        }
        
        .empty-state {
            text-align: center;
            padding: 20px;
            color: var(--gray-500);
            animation: fadeIn 0.5s ease-in;
            min-height: auto;
        }
        
        .empty-state img {
            width: 80px;
            opacity: 0.4;
            margin-bottom: 16px;
            transition: all 0.3s ease;
        }
        
        .empty-state:hover img {
            opacity: 0.6;
            transform: scale(1.05);
        }
        
        /* Smooth animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        /* Add entrance animations to sections */
        .header {
            animation: slideIn 0.6s ease-out;
        }
        
        .planning-section {
            animation: fadeIn 0.8s ease-out 0.1s both;
        }
        
        .content-table-container {
            animation: fadeIn 0.8s ease-out 0.2s both;
        }
        
        .actions-section {
            animation: fadeIn 0.8s ease-out 0.3s both;
        }
        
        /* Button press effect */
        .btn:active {
            transform: translateY(1px);
        }
        
        /* Subtle hover effects */
        .content-row {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .content-row:hover {
            background: var(--gray-25);
            transform: none;
            box-shadow: none;
        }
        
        /* Table Cell Content Styling */
        .content-table .editable-cell {
            width: 100%;
            border: 1px solid transparent;
            background: transparent;
            padding: 4px;
            font-size: 11px;
            margin: 0;
            box-sizing: border-box;
            font-family: inherit;
        }
        
        .content-table .editable-cell:focus {
            background: rgba(16, 185, 129, 0.05);
            border-color: var(--primary-green);
            outline: none;
        }
        
        .content-table .control-btn {
            padding: 4px 6px;
            font-size: 10px;
            margin: 1px;
            border: 1px solid var(--gray-200);
            background: white;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .content-table input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
            cursor: pointer;
        }
        
        
        
        /* Compact control buttons */
        .control-btn {
            font-size: 11px;
            padding: 4px 8px;
        }
        
        /* Row checkbox styling */
        .row-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            margin: 0;
        }
        
        /* Drag handle styling */
        .drag-handle {
            cursor: grab !important;
            color: #666;
            user-select: none;
            font-size: 14px;
        }
        
        .content-row[draggable="true"]:hover .drag-handle {
            color: var(--primary-green);
        }
        
        .content-row.dragging {
            opacity: 0.5 !important;
        }
        
        .status-indicator {
            transition: color 0.2s ease;
        }
        
        .content-row:hover .drag-handle {
            color: var(--primary-green) !important;
        }
        
        /* User-modified content styling */
        .content-row.user-modified {
            background: rgba(255, 107, 53, 0.05) !important;
            border-left: 3px solid #ff6b35;
        }
        
        .content-row.user-modified:hover {
            background: rgba(255, 107, 53, 0.1) !important;
        }
        
        .user-modified .status-indicator {
            animation: userModifiedPulse 2s ease-in-out infinite;
        }
        
        @keyframes userModifiedPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Draggable planning item styling */
        .draggable-planning-item {
            cursor: grab;
            transition: background-color 0.2s ease;
        }
        
        .draggable-planning-item:hover {
            background-color: rgba(16, 185, 129, 0.05);
        }
        
        .draggable-planning-item:active {
            cursor: grabbing;
        }
        
        /* Drag feedback for FullCalendar external draggable */
        .fc-event-dragging {
            opacity: 0.7;
            transform: rotate(3deg);
        }
        
        .priority-select {
            padding: 2px 3px;
            border-radius: 3px;
            border: 1px solid var(--gray-300);
            font-size: 10px;
            font-weight: 600;
            box-sizing: border-box;
            width: 100%;
            margin: 0;
        }
        
        @media (max-width: 768px) {
            .dashboard {
                padding: 8px;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .planning-section, .content-table-container, .actions-section {
                padding: 16px;
            }
            
            .content-table {
                font-size: 13px;
            }
            
            .action-buttons {
                flex-direction: column;
                gap: 8px;
            }
        }

        /* Compact footer layout styles */
        .compact-footer {
            padding: 15px 0;
            background: var(--gray-50);
            border-radius: 8px;
        }

        .summary-compact {
            margin-bottom: 15px;
        }

        .summary-items {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .summary-stat {
            color: var(--gray-600);
            font-size: 14px;
        }

        .summary-stat strong {
            color: var(--gray-900);
            font-weight: 600;
        }

        .action-row {
            display: flex;
            justify-content: center;
        }

        .action-buttons-compact {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-compact {
            padding: 8px 16px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .btn-submit {
            background: var(--primary-color);
            color: white;
        }

        .btn-submit:hover {
            background: var(--primary-dark);
        }

        .btn-export {
            background: var(--secondary-color);
            color: white;
        }

        .btn-export:hover {
            background: var(--secondary-dark);
        }

        .btn-infrastructure {
            background: #8b5cf6;
            color: white;
        }

        .btn-infrastructure:hover {
            background: #7c3aed;
        }

        .btn-clear {
            background: var(--gray-200);
            color: var(--gray-700);
        }

        .btn-clear:hover {
            background: var(--gray-300);
        }

        /* Mobile responsive for compact layout */
        @media (max-width: 640px) {
            .summary-items {
                flex-direction: column;
                gap: 8px;
                text-align: center;
            }

            .action-buttons-compact {
                flex-direction: column;
                width: 100%;
                max-width: 200px;
                margin: 0 auto;
            }

            .btn-compact {
                width: 100%;
            }
        }
        
        /* Content Creation Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            position: relative;
        }
        
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--gray-200);
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--gray-800);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--gray-400);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .modal-close:hover {
            background: var(--gray-100);
            color: var(--gray-600);
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-label {
            display: block;
            font-weight: 500;
            color: var(--gray-700);
            margin-bottom: 6px;
            font-size: 14px;
        }
        
        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--gray-300);
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: white;
        }
        
        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--primary-green);
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
        }
        
        .form-textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid var(--gray-200);
        }
        
        .btn-modal {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        
        .btn-cancel {
            background: white;
            color: var(--gray-600);
            border-color: var(--gray-300);
        }
        
        .btn-cancel:hover {
            background: var(--gray-50);
        }
        
        .btn-create {
            background: var(--primary-green);
            color: white;
        }
        
        .btn-create:hover {
            background: #059669;
        }
        
        .btn-create:disabled {
            background: var(--gray-400);
            cursor: not-allowed;
        }
        
        .date-info {
            background: var(--gray-50);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 14px;
            color: var(--gray-600);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Content Details Card Styles */
        .content-details-modal {
            max-width: 800px;
            width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s ease;
        }
        
        .modal-overlay.active .content-details-modal {
            transform: scale(1) translateY(0);
        }

        /* NEW: Content Preview Modal Styles */
        .content-preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.2s ease;
        }

        .content-preview-modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        .content-preview-modal-content {
            position: relative;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 90vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            animation: slideUp 0.2s ease;
        }

        .content-preview-modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f9fafb;
        }

        .content-preview-modal-header h3 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 24px;
            color: #6b7280;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .modal-close-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .content-preview-modal-info {
            padding: 16px 24px;
            background: #f3f4f6;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
        }

        .preview-info-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-label {
            font-weight: 600;
            color: #4b5563;
            font-size: 0.875rem;
        }

        .info-value {
            color: #1f2937;
            font-size: 0.875rem;
        }

        .content-preview-modal-body {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
        }

        .generated-content-text {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            color: #374151;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
        }

        .content-preview-modal-actions {
            padding: 16px 24px;
            border-top: 1px solid #e5e7eb;
            background: #f9fafb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .copy-content-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .copy-content-btn:hover {
            background: #059669;
        }

        .close-preview-btn {
            background: #6b7280;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .close-preview-btn:hover {
            background: #4b5563;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .details-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 24px;
            border-radius: 16px 16px 0 0;
        }
        
        .details-title {
            font-size: 24px;
            font-weight: 700;
            margin: 0 0 8px 0;
            line-height: 1.2;
        }
        
        .details-meta {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-top: 12px;
            font-size: 14px;
            opacity: 0.9;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255, 255, 255, 0.15);
            padding: 6px 12px;
            border-radius: 20px;
            backdrop-filter: blur(4px);
        }
        
        .details-body {
            padding: 24px;
        }
        
        .details-section {
            margin-bottom: 24px;
        }
        
        .details-section h3 {
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 12px 0;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .details-content {
            background: #f9fafb;
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            margin-bottom: 16px;
        }
        
        .keywords-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }
        
        .keyword-tag {
            background: #eff6ff;
            color: #1e40af;
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 500;
            border: 1px solid #bfdbfe;
        }
        
        .file-access-section {
            background: #f0f9ff;
            border: 2px dashed #0ea5e9;
            border-radius: 12px;
            padding: 24px;
            text-align: center;
        }
        
        .file-access-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.7;
        }
        
        .file-links {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 16px;
        }
        
        .file-link {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: white;
            border: 1px solid #0ea5e9;
            border-radius: 25px;
            text-decoration: none;
            color: #0369a1;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .file-link:hover {
            background: #0ea5e9;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
        }
        
        .priority-badge {
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .priority-HIGH {
            background: #fef2f2;
            color: #dc2626;
            border: 1px solid #fecaca;
        }
        
        .priority-MEDIUM {
            background: #fffbeb;
            color: #d97706;
            border: 1px solid #fed7aa;
        }
        
        .priority-LOW {
            background: #f0fdf4;
            color: #16a34a;
            border: 1px solid #bbf7d0;
        }
        
        /* Removed conflicting content-type-badge style */
        
        .selection-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: #f9fafb;
            border-radius: 8px;
            margin-top: 16px;
        }
        
        .selection-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #3b82f6;
        }
        
        .details-actions {
            display: flex;
            gap: 12px;
            justify-content: space-between;
            padding: 24px;
            border-top: 1px solid #e5e7eb;
            background: #f9fafb;
            border-radius: 0 0 16px 16px;
        }
        
        .action-group {
            display: flex;
            gap: 8px;
        }
        
        .btn-secondary {
            padding: 10px 20px;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            color: #374151;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-secondary:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }
        
        .btn-danger {
            background: #dc2626;
            border-color: #dc2626;
            color: white;
        }
        
        .btn-danger:hover {
            background: #b91c1c;
            border-color: #b91c1c;
        }
        
        /* Modern Edit Modal Styles */
        .modern-edit-modal {
            max-width: 720px;
            width: 95%;
            max-height: 90vh;
            padding: 0;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .modal-header-modern {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 24px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-shrink: 0;
        }
        
        .header-left .modal-title {
            font-size: 24px;
            font-weight: 700;
            margin: 0 0 4px 0;
            line-height: 1.2;
        }
        
        .header-left .modal-subtitle {
            font-size: 14px;
            margin: 0;
            opacity: 0.9;
            font-weight: 400;
        }
        
        .header-right {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .content-type-badge, .priority-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Removed second conflicting content-type-badge style */
        
        .priority-badge.priority-high {
            background: #dc2626;
            color: white;
        }
        
        .priority-badge.priority-medium {
            background: #f59e0b;
            color: white;
        }
        
        .priority-badge.priority-low {
            background: #10b981;
            color: white;
        }
        
        .modern-edit-form {
            padding: 24px;
            flex: 1;
            overflow-y: auto;
        }
        
        .form-section {
            margin-bottom: 20px;
        }
        
        .form-section:last-of-type {
            margin-bottom: 0;
        }
        
        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }
        
        .form-group-modern {
            margin-bottom: 16px;
        }
        
        .form-label-modern {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 14px;
            color: #374151;
        }
        
        .label-icon {
            font-size: 16px;
        }
        
        .label-text {
            font-size: 14px;
        }
        
        .form-input-modern {
            width: 100%;
            padding: 10px 14px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s ease;
            background: #ffffff;
        }
        
        .form-input-modern:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .textarea-modern {
            resize: vertical;
            min-height: 40px;
        }
        
        .select-modern {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 12px center;
            background-repeat: no-repeat;
            background-size: 16px;
            padding-right: 40px;
            appearance: none;
        }
        
        .date-input-modern {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%236b7280'%3e%3cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z' /%3e%3c/svg%3e");
            background-position: right 12px center;
            background-repeat: no-repeat;
            background-size: 16px;
            padding-right: 40px;
        }
        
        .modal-actions-modern {
            padding: 16px 24px;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            flex-shrink: 0;
        }
        
        .btn-save-modern {
            display: flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-save-modern:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn-cancel-modern {
            background: #f3f4f6;
            color: #6b7280;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-cancel-modern:hover {
            background: #e5e7eb;
            color: #4b5563;
        }
        
        .btn-icon {
            font-size: 16px;
        }
        
        .btn-text {
            font-size: 14px;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .modern-edit-modal {
                width: 95%;
                max-height: 95vh;
                margin: 0;
            }
            
            .modal-header-modern {
                padding: 20px 24px;
                flex-direction: column;
                gap: 16px;
                align-items: flex-start;
            }
            
            .modern-edit-form {
                padding: 24px;
            }
            
            .form-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .modal-actions-modern {
                padding: 20px 24px;
                flex-direction: column-reverse;
            }
            
            .btn-save-modern, .btn-cancel-modern {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <!-- Header -->
        <div class="header">
            <div class="header-content">
                <div class="header-main">
                    <h1>🚀 {{CLIENT_NAME}} Content Planning Hub</h1>
                    <p class="header-subtitle">Visual Content Scheduling & Airtable Integration Dashboard</p>
                </div>
                
                <div class="sync-status">
                    <div class="sync-indicator">
                        <div class="sync-dot connected" id="syncIndicator"></div>
                        <span>Claude Code: <span id="syncStatus">Connected</span></span>
                    </div>
                    <div class="sync-indicator">
                        <div class="sync-dot connected"></div>
                        <span>Session: <span id="sessionId">Initializing...</span></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Unified Planning Workspace -->
        <div class="planning-workspace" id="planningWorkspace">
            <!-- Planning Sidebar (Left 35%) -->
            <div class="planning-sidebar">


            </div>

        </div>


        <!-- Airtable Views Section -->
        <div class="collapsible-section expanded" id="airtableSection">
            <div class="collapsible-header" onclick="
                var section = document.getElementById('airtableSection');
                var content = section.querySelector('.collapsible-content');
                var arrow = section.querySelector('.collapsible-arrow');
                if (section.classList.contains('collapsed')) {
                    section.classList.remove('collapsed');
                    arrow.textContent = '▼';
                } else {
                    section.classList.add('collapsed');
                    arrow.textContent = '▶';
                }
            " style="cursor: pointer;">
                <div class="collapsible-title">
                    📊 Live Airtable Views
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <button onclick="event.stopPropagation(); refreshAirtableData()" style="background: var(--secondary-color); color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; cursor: pointer;" title="Refresh Airtable Data">
                        🔄 Refresh
                    </button>
                    <div class="collapsible-arrow">▶</div>
                </div>
            </div>
            <div class="collapsible-content">
                <div class="airtable-section">
                    <p style="color: #666; margin-bottom: 20px; padding: 0 20px; padding-top: 16px;">
                        View your content from Airtable in different formats.
                        <br><a href="https://airtable.com/appS6XjjRUrELJRgC/" target="_blank" style="color: #4CAF50; text-decoration: none; font-weight: 500;">
                            🔗 Open Full Airtable Base
                        </a>
                        <br><a href="email-preview.html" target="_blank" style="color: #ef4444; text-decoration: none; font-weight: 500;">
                            📧 Email Campaign Preview
                        </a>
                        <br><a href="crisis-alert.html" target="_blank" style="color: #dc2626; text-decoration: none; font-weight: 500;">
                            🚨 Crisis Alert System
                        </a>
                    </p>
                    
                    <!-- Tab Navigation -->
                    <div class="tab-navigation" style="margin: 0 20px;">
                        <button class="tab-button active" onclick="switchTab('inventory-card')">📋 Planned</button>
                        <button class="tab-button" onclick="switchTab('todo-card')">🎴 In Production</button>
                        <button class="tab-button" onclick="switchTab('ready-card')">✅ Ready</button>
                    </div>
                    
                    <!-- Tab Content -->
                    <div class="tab-content" style="padding: 20px;">
                        <!-- Planned - Card View -->
                        <div id="inventory-card" class="tab-pane active">
                            <div class="iframe-container" data-src="https://airtable.com/embed/appS6XjjRUrELJRgC/shr9MzUotKm1GFD3C?layout=card&viewControls=on">
                                <iframe 
                                    class="airtable-embed" 
                                    src="https://airtable.com/embed/appS6XjjRUrELJRgC/shr9MzUotKm1GFD3C?layout=card&viewControls=on" 
                                    frameborder="0" 
                                    onmousewheel="" 
                                    width="100%" 
                                    height="533" 
                                    style="background: transparent; border: 1px solid #ccc; border-radius: 8px;">
                                </iframe>
                            </div>
                        </div>
                        
                        <!-- In Production - Card View -->
                        <div id="todo-card" class="tab-pane">
                            <div class="iframe-container" data-src="https://airtable.com/embed/appS6XjjRUrELJRgC/shrXePkz0qqKaflso?layout=card&viewControls=on">
                                <div class="loading-placeholder">
                                    <p>🎴 Loading In Production View...</p>
                                    <p style="color: #666; font-size: 14px;">Click to load this view</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Ready - Card View -->
                        <div id="ready-card" class="tab-pane">
                            <div class="iframe-container" data-src="https://airtable.com/embed/appS6XjjRUrELJRgC/shrLHz4uxUAYFwsaj?layout=card&viewControls=on">
                                <div class="loading-placeholder">
                                    <p>✅ Loading Ready View...</p>
                                    <p style="color: #666; font-size: 14px;">Click to load this view</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Content Analytics Section -->
        <div class="collapsible-section collapsed" id="analyticsSection">
            <div class="collapsible-header" onclick="
                var section = document.getElementById('analyticsSection');
                var arrow = section.querySelector('.collapsible-arrow');
                if (section.classList.contains('collapsed')) {
                    section.classList.remove('collapsed');
                    arrow.textContent = '▼';
                } else {
                    section.classList.add('collapsed');
                    arrow.textContent = '▶';
                }
            " style="cursor: pointer;">
                <div class="collapsible-title">
                    📊 Content Analytics Dashboard
                </div>
                <div class="collapsible-arrow">▶</div>
            </div>
            <div class="collapsible-content">
                <div class="analytics-content">
                    <!-- Analytics Controls -->
                    <div class="section-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 0 20px;">
                        <h3 style="margin: 0; font-size: 1.1rem; font-weight: 600; color: #374151;">📊 Analytics Dashboard</h3>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <button onclick="console.log('Analytics refresh clicked'); logStatus('📊 Analytics refreshed');" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer;">🔄 Refresh</button>
                        </div>
                    </div>
                    
                    <!-- Analytics Summary Stats -->
                    <div class="analytics-summary">
                        <div class="analytics-stat">
                            <div class="analytics-stat-number" id="analyticsTotal">0</div>
                            <div class="analytics-stat-label">Total Content</div>
                        </div>
                        <div class="analytics-stat">
                            <div class="analytics-stat-number" id="analyticsLocal">0</div>
                            <div class="analytics-stat-label">Local Generated</div>
                        </div>
                        <div class="analytics-stat">
                            <div class="analytics-stat-number" id="analyticsSystematic">0</div>
                            <div class="analytics-stat-label">Systematic</div>
                        </div>
                        <div class="analytics-stat">
                            <div class="analytics-stat-number" id="analyticsHighPriority">0</div>
                            <div class="analytics-stat-label">High Priority</div>
                        </div>
                    </div>

                    <!-- Charts Grid -->
                    <div class="analytics-grid">
                        <!-- Content Type Distribution -->
                        <div class="chart-container">
                            <div class="chart-header">
                                <div class="chart-title">📊 Content Type Distribution</div>
                            </div>
                            <div class="chart-canvas">
                                <canvas id="contentTypeChart"></canvas>
                            </div>
                        </div>

                        <!-- Generation Type Split -->
                        <div class="chart-container">
                            <div class="chart-header">
                                <div class="chart-title">⚡ Generation Strategy</div>
                            </div>
                            <div class="chart-canvas">
                                <canvas id="generationTypeChart"></canvas>
                            </div>
                        </div>

                        <!-- Priority Breakdown -->
                        <div class="chart-container">
                            <div class="chart-header">
                                <div class="chart-title">🎯 Priority Distribution</div>
                            </div>
                            <div class="chart-canvas">
                                <canvas id="priorityChart"></canvas>
                            </div>
                        </div>

                        <!-- Location Focus -->
                        <div class="chart-container">
                            <div class="chart-header">
                                <div class="chart-title">🗺️ Market Coverage</div>
                            </div>
                            <div class="chart-canvas">
                                <canvas id="locationChart"></canvas>
                            </div>
                        </div>

                        <!-- Seasonal Distribution -->
                        <div class="chart-container">
                            <div class="chart-header">
                                <div class="chart-title">🌍 Seasonal Strategy</div>
                            </div>
                            <div class="chart-canvas">
                                <canvas id="seasonalChart"></canvas>
                            </div>
                        </div>

                        <!-- SEO Opportunity Map -->
                        <div class="chart-container">
                            <div class="chart-header">
                                <div class="chart-title">🔍 SEO Opportunity Map</div>
                            </div>
                            <div class="chart-canvas">
                                <canvas id="seoChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Strategic Insights Removed - Focusing on staging workflow -->
                </div>
            </div>
        </div>



        <!-- Google Drive File Access Section -->
        <div class="collapsible-section expanded" id="googleDriveSection">
            <div class="collapsible-header" onclick="
                var section = document.getElementById('googleDriveSection');
                var arrow = section.querySelector('.collapsible-arrow');
                if (section.classList.contains('collapsed')) {
                    section.classList.remove('collapsed');
                    arrow.textContent = '▼';
                } else {
                    section.classList.add('collapsed');
                    arrow.textContent = '▶';
                }
            " style="cursor: pointer;">
                <div class="collapsible-title">
                    📁 Google Drive File Access
                </div>
                <div class="collapsible-arrow">▶</div>
            </div>
            <div class="collapsible-content">
                <div class="drive-content" style="padding: 20px;">
                    <div class="drive-instructions" style="margin-bottom: 15px; padding: 15px; background: var(--gray-50); border-radius: 8px; border-left: 4px solid var(--primary-green);">
                        <h4 style="margin: 0 0 8px 0; color: var(--gray-800);">{{CLIENT_NAME}} Content File Access</h4>
                        <p style="margin: 0; color: var(--gray-600); font-size: 14px;">
                            Access your Google Drive files directly from the dashboard. Use this for managing content assets, 
                            templates, research documents, and collaborative files.
                        </p>
                    </div>
                    
                    <div class="drive-container" style="border: 1px solid var(--gray-300); border-radius: 8px; overflow: hidden; background: white;">
                        <div id="driveSetupMessage" style="padding: 40px; text-align: center; color: var(--gray-600);">
                            <div style="font-size: 48px; margin-bottom: 20px;">📁</div>
                            <h3 style="margin: 0 0 15px 0; color: var(--gray-800);">Google Drive Integration Setup</h3>
                            <p style="margin: 0 0 20px 0; font-size: 14px; line-height: 1.5;">
                                To integrate your Google Drive, you'll need to:<br>
                                1. Create a shared folder for {{CLIENT_NAME}} content<br>
                                2. Get the folder's share link<br>
                                3. Update the iframe source below
                            </p>
                            <div style="margin: 20px 0; padding: 15px; background: var(--gray-50); border-radius: 6px; font-family: monospace; font-size: 12px; text-align: left;">
                                <strong>Example URL format:</strong><br>
                                https://drive.google.com/embeddedfolderview?id=YOUR_FOLDER_ID&usp=sharing
                            </div>
                            <button 
                                onclick="setupGoogleDrive()" 
                                style="background: var(--primary-green); color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                                🔧 Set Up Google Drive
                            </button>
                        </div>
                        <iframe 
                            id="googleDriveIframe"
                            src="" 
                            width="100%" 
                            height="600" 
                            frameborder="0"
                            style="border: none; display: none;"
                            title="{{CLIENT_NAME}} Google Drive Files">
                        </iframe>
                    </div>
                    
                    <div class="drive-actions" style="margin-top: 15px; display: flex; gap: 10px; justify-content: space-between; align-items: center;">
                        <div class="drive-info" style="color: var(--gray-600); font-size: 14px;">
                            📄 Quick access to content templates, research docs, and assets
                        </div>
                        <div class="drive-controls">
                            <button 
                                class="action-btn" 
                                onclick="refreshDriveIframe()" 
                                style="background: var(--primary-green); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;"
                            >
                                🔄 Refresh Drive
                            </button>
                            <button 
                                class="action-btn" 
                                onclick="openDriveInNewTab()" 
                                style="background: var(--gray-600); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; margin-left: 8px;"
                            >
                                🔗 Open in New Tab
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Log Section -->
        <div class="collapsible-section collapsed" id="statusLogSection">
            <div class="collapsible-header" onclick="
                var section = document.getElementById('statusLogSection');
                var arrow = section.querySelector('.collapsible-arrow');
                if (section.classList.contains('collapsed')) {
                    section.classList.remove('collapsed');
                    arrow.textContent = '▼';
                } else {
                    section.classList.add('collapsed');
                    arrow.textContent = '▶';
                }
            " style="cursor: pointer;">
                <div class="collapsible-title">
                    📈 Status Log
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <button onclick="event.stopPropagation(); copyStatusLog()" style="background: var(--secondary-color); color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; cursor: pointer;" title="Copy Status Log to Clipboard">
                        📋 Copy
                    </button>
                    <div class="collapsible-arrow">▶</div>
                </div>
            </div>
            <div class="collapsible-content">
                <div class="status-section" style="padding: 20px;">
                    <div class="status-log" id="statusLog">
                        Dashboard initialized. Ready for content planning...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // IMMEDIATE TEST: Define toggleSection at script start
        console.log('🔄 Defining toggleSection immediately...');
        
        // Define Archive Functions EARLY (before any calls to them)
        window.refreshArchiveList = async function() {
            console.log('📦 Refreshing archive list...');
            logStatus('📦 Loading archived planning sessions...');
            
            try {
                const response = await fetch('http://localhost:3002/api/archives', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const archives = await response.json();
                displayArchiveList(archives);
                logStatus(`📦 Found ${archives.length} archived planning sessions`);
                
                // DISABLED: Auto-expand archive section - keep collapsed on initial load
                // Update section header to show archive count but keep section collapsed
                if (archives.length > 0) {
                    const archiveSection = document.getElementById('archiveSection');
                    if (archiveSection) {
                        console.log('📦 Found', archives.length, 'archives - updating header but keeping section collapsed');
                        
                        // Update section header to show archive count
                        const sectionHeader = archiveSection.querySelector('.collapsible-header h3');
                        if (sectionHeader) {
                            sectionHeader.textContent = `📦 Planning Session Archive (${archives.length})`;
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading archive list:', error);
                const archiveContainer = document.getElementById('archive-list');
                if (archiveContainer) {
                    archiveContainer.innerHTML = `
                        <div style="padding: 40px; text-align: center; color: #dc3545;">
                            <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
                            <p style="font-size: 16px; margin-bottom: 8px;">Unable to load archive list</p>
                            <p style="font-size: 14px;">Make sure the planning data server is running</p>
                        </div>
                    `;
                }
                logStatus('❌ Failed to load archive list - server not accessible');
            }
        }
        
        function displayArchiveList(archives) {
            const archiveContainer = document.getElementById('archive-list');
            
            if (archives.length === 0) {
                archiveContainer.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: #6b7280;">
                        <div style="font-size: 48px; margin-bottom: 16px;">📦</div>
                        <p style="font-size: 16px; margin-bottom: 8px;">No archived planning sessions found</p>
                        <p style="font-size: 14px;">Archive will appear here when you clear the staging area</p>
                    </div>
                `;
                return;
            }
            
            let archiveHTML = `
                <div style="display: grid; gap: 16px;">
            `;
            
            archives.forEach(archive => {
                archiveHTML += `
                    <div style="border: 2px solid #e5e7eb; border-radius: 12px; padding: 16px; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 12px;">
                            <h4 style="margin: 0; color: #374151; font-size: 14px; font-weight: 600;">
                                📦 Session: ${archive.sessionId || 'No ID'}
                            </h4>
                            <span style="background: #f3f4f6; padding: 4px 8px; border-radius: 6px; font-size: 12px; color: #6b7280;">
                                ${archive.recordCount} records
                            </span>
                        </div>
                        <p style="margin: 0 0 12px 0; font-size: 12px; color: #6b7280;">
                            Archived: ${new Date(archive.archivedAt).toLocaleDateString()} ${new Date(archive.archivedAt).toLocaleTimeString()}
                        </p>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button 
                                onclick="previewArchive('${archive.filename}')"
                                style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500;"
                            >
                                👁️ View Details
                            </button>
                            <button 
                                onclick="restoreFromArchive('${archive.filename}')"
                                style="background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500;"
                            >
                                🔄 Restore Session
                            </button>
                        </div>
                    </div>
                `;
            });
            
            archiveHTML += `</div>`;
            archiveContainer.innerHTML = archiveHTML;
        }
        
        function toggleSection(sectionId) {
            console.log('🔄 IMMEDIATE toggleSection called with:', sectionId);
            alert('Toggle function called for: ' + sectionId);
            
            const section = document.getElementById(sectionId);
            if (!section) {
                console.error('❌ Section not found:', sectionId);
                alert('Section not found: ' + sectionId);
                return;
            }
            
            console.log('✅ Found section, current classes:', section.className);
            
            if (section.classList.contains('collapsed')) {
                section.classList.remove('collapsed');
                console.log('✅ Expanded section:', sectionId);
                alert('Expanded: ' + sectionId);
                
                // Clear manual collapse flag when user expands
                if (sectionId === 'archiveSection') {
                    section.dataset.manuallyCollapsed = 'false';
                }
                
                const arrow = section.querySelector('.collapsible-arrow');
                if (arrow) arrow.textContent = '▼';
            } else {
                section.classList.add('collapsed');
                console.log('✅ Collapsed section:', sectionId);
                alert('Collapsed: ' + sectionId);
                
                // Set manual collapse flag when user collapses archive section
                if (sectionId === 'archiveSection') {
                    section.dataset.manuallyCollapsed = 'true';
                }
                
                const arrow = section.querySelector('.collapsible-arrow');
                if (arrow) arrow.textContent = '▶';
            }
        }
        
        // Make it globally available immediately
        window.toggleSection = toggleSection;
        console.log('✅ toggleSection defined and attached to window');
        
        // Airtable Direct Integration Configuration
        const AIRTABLE_CONFIG = {
            apiKey: 'YOUR_AIRTABLE_API_KEY', // Replace with your Airtable Personal Access Token
            baseId: 'YOUR_AIRTABLE_BASE_ID',
            tableId: 'YOUR_AIRTABLE_TABLE_ID',
            apiUrl: 'https://api.airtable.com/v0'
        };

        // Update Airtable record via direct API
        async function updateAirtableRecord(record, source) {
            try {
                console.log(`🔄 Updating Airtable record: ${record.description} (${source})`);
                
                // Extract Airtable record ID (remove 'airtable_' prefix)
                const airtableRecordId = record.id.replace('airtable_', '');
                
                // Prepare the update payload with proper field mapping
                const updatePayload = {
                    fields: {
                        "Publish Date": record.targetPublishDate || record.scheduledDate
                    }
                };
                
                console.log('Airtable update payload:', updatePayload);
                console.log('Record ID:', airtableRecordId);
                
                // Make the PATCH request to Airtable
                const response = await fetch(`${AIRTABLE_CONFIG.apiUrl}/${AIRTABLE_CONFIG.baseId}/${AIRTABLE_CONFIG.tableId}/${airtableRecordId}`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `Bearer ${AIRTABLE_CONFIG.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updatePayload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Airtable update failed: ${response.status} ${response.statusText} - ${errorText}`);
                }
                
                const updatedRecord = await response.json();
                console.log('✅ Airtable record updated successfully:', updatedRecord);
                
                return updatedRecord;
                
            } catch (error) {
                console.error('❌ Airtable update error:', error);
                throw error;
            }
        }

        // Global state management - FIXED to use window.contentData consistently
        window.contentData = [];
        let editMode = true;
        let isRecording = false;
        let recognition = null;
        let sessionId = null;
        // Calendar variable removed (staging dashboard only)
        
        // Helper function to prevent drag interference with editable fields
        function preventDragInterference(element) {
            element.addEventListener('mousedown', (e) => e.stopPropagation());
            element.addEventListener('dragstart', (e) => e.preventDefault());
        }
        let currentView = 'table';
        
        // Analytics chart instances
        let analyticsCharts = {
            contentType: null,
            generationType: null,
            priority: null,
            location: null,
            seasonal: null,
            seo: null
        };

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // Initialize global content data array
                if (!window.contentData) {
                    window.contentData = [];
                }
                
                console.log('🚀 Starting dashboard initialization...');
                initializeDashboard();
                // Drag disabled; no sortable setup
                // Calendar removed - now staging dashboard only
                await startClaudeSync();
                console.log('✅ Dashboard initialization completed successfully');
            } catch (error) {
                console.error('❌ Dashboard initialization failed:', error);
                logStatus(`❌ Dashboard initialization failed: ${error.message}`);
            }
            
            // Add native HTML5 drop support to calendar after initialization
            setTimeout(() => {
                // Calendar drop zone removed
            }, 500);
            
            // Initialize analytics functionality
            initializeExportButtons();
            
            // Load analytics data after a short delay to ensure content is loaded
            setTimeout(() => {
                loadAnalyticsData();
            }, 1000);
            
            // Load persisted Google Drive settings
            setTimeout(() => {
                loadPersistedGoogleDrive();
            }, 500);
            
            // Auto-populate archive section on dashboard load - increased delay for reliability
            setTimeout(() => {
                console.log('🔄 Auto-loading archive list...');
                refreshArchiveList();
            }, 2500);
            
            // Archive loading event listener removed - handled by inline onclick with manuallyCollapsed flag
        });

        // Initialize dashboard components
        function initializeDashboard() {
            logStatus('🔄 Initializing {{CLIENT_NAME}} Planning Dashboard...');
            
            // Check for speech recognition support
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                setupSpeechRecognition();
                logStatus('✅ Voice recognition available');
            } else {
                logStatus('⚠️ Voice recognition not supported in this browser');
                document.getElementById('voiceBtn').disabled = true;
            }
            
            // FIXED: Don't poll Airtable here - let Claude sync handle data loading
            // This was overriding Claude planning records
            // pollAirtable();
            
            // DISABLED: Automatic polling for calendar updates (was consuming excessive N8N executions)
            // startAutomaticPolling();
            
            updateSummaryStats();
            updateEmptyState();
            
            logStatus('✅ Dashboard ready for content planning');
        }

        // Setup speech recognition
        function setupSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            
            recognition.onstart = function() {
                logStatus('🎤 Voice recording started...');
            };
            
            recognition.onresult = function(event) {
                const transcript = event.results[0][0].transcript;
                document.getElementById('textInput').value = transcript;
                logStatus(`✅ Voice captured: "${transcript}"`);
                
                // Auto-process voice input with real Claude Code integration
                setTimeout(() => {
                    processVoiceWithRealClaudeCode(transcript);
                }, 500);
            };
            
            recognition.onerror = function(event) {
                logStatus(`❌ Voice recognition error: ${event.error}`);
                stopVoiceRecording();
            };
            
            recognition.onend = function() {
                stopVoiceRecording();
            };
        }

        // Voice recording controls
        function toggleVoiceRecording() {
            if (isRecording) {
                stopVoiceRecording();
            } else {
                startVoiceRecording();
            }
        }

        function startVoiceRecording() {
            if (recognition) {
                isRecording = true;
                const btn = document.getElementById('voiceBtn');
                btn.textContent = '🛑 Stop Recording';
                btn.classList.add('recording');
                recognition.start();
            }
        }

        function stopVoiceRecording() {
            if (recognition && isRecording) {
                isRecording = false;
                const btn = document.getElementById('voiceBtn');
                btn.textContent = '🎤 Start Voice Planning';
                btn.classList.remove('recording');
                recognition.stop();
            }
        }

        // Start Claude Code synchronization
        async function startClaudeSync() {
            try {
                // Initialize session
                sessionId = `session_${Date.now()}`;
                document.getElementById('sessionId').textContent = sessionId;
                
                logStatus('🔄 Starting Claude Code sync...');
                
                // Load initial state
                await loadExistingState();
                
                logStatus('✅ Claude Code sync established');
                
                // DISABLED: Claude Code auto-polling to reduce overall system load
                // const pollingInterval = setInterval(async () => {
                //     if (autoSyncPaused) {
                //         console.log('🚫 Auto-sync paused - skipping Claude Code poll');
                //         return;
                //     }
                //     
                //     try {
                //         logStatus('🔄 Auto-polling for new records...');
                //         await loadFromClaude();
                //     } catch (error) {
                //         logStatus('⚠️ Auto-poll failed - will retry in 1 minute');
                //     }
                // }, 60000);
                
                logStatus('⚠️ Auto-polling DISABLED - data loads on page load and manual refresh only');
                
                // Store interval ID for cleanup if needed
                window.claudeSyncInterval = null;
            } catch (error) {
                console.error('⚠️ Claude sync error:', error);
                logStatus(`⚠️ Sync warning: ${error.message} - continuing with empty state`);
                // Continue with empty state if sync fails
                populateCards();
            }
        }

        // Load existing planning state (if any)
        async function loadExistingState() {
            let claudeDataLoaded = false;
            
            // Try to load from Claude Code sync first
            try {
                await loadFromClaude();
                claudeDataLoaded = true;
                logStatus('✅ Claude planning data loaded successfully');
            } catch (error) {
                logStatus('⚠️ Could not load from Claude Code sync - trying fallback');
                console.warn('Claude sync error:', error);
                
                // Try fallback to localStorage
                const saved = localStorage.getItem('client_planning_state');
                if (saved) {
                    try {
                        const state = JSON.parse(saved);
                        window.contentData = state.content_records || [];
                        logStatus(`📂 Loaded ${window.contentData.length} existing records from localStorage`);
                        populateCards();
                        claudeDataLoaded = true;
                    } catch (localError) {
                        logStatus('⚠️ Could not load previous state from localStorage');
                    }
                }
            }
            
            // ALWAYS try to load Airtable data for calendar context (regardless of Claude data success)
            try {
                logStatus('🔄 Loading Airtable calendar data...');
                await pollAirtable();
                logStatus('✅ Airtable calendar data loaded successfully');
                
                // CRITICAL FIX: Refresh calendar after Airtable data loads
                if (false) { // Calendar disabled
                    setTimeout(() => {
                        // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                        updateCalendarStats();
                        console.log('✅ Calendar refreshed after initial Airtable data load');
                    }, 100);
                }
            } catch (airtableError) {
                logStatus('⚠️ Could not load Airtable calendar data - calendar will be empty until manual refresh');
                console.warn('Airtable sync error:', airtableError);
            }
            
            if (!claudeDataLoaded && !window.contentData?.length) {
                logStatus('📝 No existing content found - ready for new planning');
            }
        }

        // Process voice input with real Claude Code integration
        async function processVoiceWithRealClaudeCode(transcript) {
            logStatus('🎤 Processing voice input with Claude Code agents...');
            logStatus('📡 Sending to real Claude Code planning system...');
            
            try {
                const response = await fetch('/api/voice-planning', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ transcript })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    logStatus('✅ Voice processing completed successfully');
                    if (result.fallback) {
                        logStatus('⚠️ Used fallback content generation');
                    } else {
                        logStatus('🎯 Content generated by Claude Code agents');
                    }
                    logStatus(result.message);
                    
                    // Refresh data from sync system
                    await loadFromClaude();
                } else {
                    logStatus(`❌ Voice processing failed: ${result.error}`);
                }
                
            } catch (error) {
                logStatus(`❌ Voice processing error: ${error.message}`);
                console.error('Voice processing error:', error);
            }
        }
        
        // Process text planning input
        function processTextPlanning() {
            const input = document.getElementById('textInput').value.trim();
            if (!input) {
                logStatus('❌ Please enter planning requirements');
                return;
            }
            
            logStatus('🧠 Processing planning input with Claude Code agents...');
            
            // For text input, also use real Claude Code integration
            processVoiceWithRealClaudeCode(input);
        }

        // Simulate Claude Code planning (replace with real integration)
        function simulateClaudePlanning(input = null) {
            const planningInput = input || document.getElementById('textInput').value || 'Sample planning request';
            
            logStatus('🔄 Claude Code agents analyzing requirements...');
            logStatus('📚 Consulting {{CLIENT_NAME}} brand guidelines...');
            logStatus('🔍 Researching keywords and seasonal patterns...');
            
            setTimeout(() => {
                // Generate sample content based on input
                const newContent = generateSampleContent(planningInput);
                
                // Add to content data
                newContent.forEach((item, index) => {
                    const record = {
                        id: `temp_${Date.now()}_${index}`,
                        selected: true,
                        order: window.contentData.length + index,
                        source: 'claude',
                        ...item,
                        created_at: new Date().toISOString(),
                        modified_at: new Date().toISOString()
                    };
                    window.contentData.push(record);
                });
                
                populateCards();
                logStatus(`✅ Generated ${newContent.length} content records from Claude Code`);
                
                // Sync with Claude Code state
                syncToClaude();
                
            }, 2000);
        }

        // Generate content based on actual user input (simulates Claude Code intelligence)
        function generateSampleContent(input) {
            console.log('Analyzing input:', input);
            
            // Parse the input for key information
            const inputLower = input.toLowerCase();
            
            // Extract number of posts
            let count = 3; // default
            const numberMatches = input.match(/(\d+)\s*(blog posts?|social media posts?|posts?|pieces?|content)/i);
            if (numberMatches) {
                count = parseInt(numberMatches[1]);
            }
            
            // Extract content type
            let defaultContentType = 'Social Media';
            if (inputLower.includes('blog post') || inputLower.includes('blog')) {
                defaultContentType = 'Blog Post';
            } else if (inputLower.includes('location page') || inputLower.includes('landing page')) {
                defaultContentType = 'Location Page';
            }
            
            // Extract season/timing
            let season = 'Fall';
            let seasonalKeyword = 'fall';
            if (inputLower.includes('winter') || inputLower.includes('december') || inputLower.includes('january') || inputLower.includes('february')) {
                season = 'Winter';
                seasonalKeyword = 'winter';
            } else if (inputLower.includes('spring') || inputLower.includes('march') || inputLower.includes('april') || inputLower.includes('may')) {
                season = 'Spring';
                seasonalKeyword = 'spring';
            } else if (inputLower.includes('summer') || inputLower.includes('june') || inputLower.includes('july') || inputLower.includes('august')) {
                season = 'Summer';
                seasonalKeyword = 'summer';
            }
            
            // Extract pest type
            let pestType = 'General';
            if (inputLower.includes('ant')) pestType = 'Ants';
            else if (inputLower.includes('spider')) pestType = 'Spiders';
            else if (inputLower.includes('rodent') || inputLower.includes('mice') || inputLower.includes('rat')) pestType = 'Rodents';
            else if (inputLower.includes('termite')) pestType = 'Termites';
            else if (inputLower.includes('mosquito')) pestType = 'Mosquitoes';
            else if (inputLower.includes('wasp') || inputLower.includes('bee')) pestType = 'Wasps';
            
            // Extract location focus
            let primaryLocation = 'Multi-State';
            let locationFocus = false;
            if (inputLower.includes('illinois') || inputLower.includes('dixon') || inputLower.includes('sycamore')) {
                locationFocus = true;
                if (inputLower.includes('dixon')) primaryLocation = 'Dixon IL';
                else if (inputLower.includes('sycamore')) primaryLocation = 'Sycamore IL';
                else if (inputLower.includes('rockford')) primaryLocation = 'Rockford IL';
                else if (inputLower.includes('dekalb')) primaryLocation = 'DeKalb IL';
                else primaryLocation = 'Illinois';
            }
            
            // Extract theme/focus
            let theme = 'prevention';
            if (inputLower.includes('control')) theme = 'control';
            else if (inputLower.includes('treatment')) theme = 'treatment';
            else if (inputLower.includes('preparation') || inputLower.includes('prep')) theme = 'preparation';
            
            // Generate content based on analysis
            const generatedContent = [];
            
            for (let i = 0; i < count; i++) {
                let description, targetLocation, contentFormat, priority, keywords, notes;
                
                if (defaultContentType === 'Social Media') {
                    // Social media posts are location-agnostic per Brad's rules
                    targetLocation = 'Multi-State';
                    contentFormat = i % 2 === 0 ? 'Facebook Post' : 'Instagram Post';
                    priority = 'MEDIUM';
                    
                    const topics = [
                        'Prevention Tips', 'Safety Alert', 'Seasonal Guide', 'Home Protection', 
                        'Family Safety', 'Quick Tips', 'Expert Advice', 'Preparation Guide'
                    ];
                    const formats = [
                        'Infographic', 'Carousel', 'Video Tips', 'Quick Guide', 
                        'Checklist', 'Alert Post', 'Tips Series', 'How-To'
                    ];
                    
                    if (pestType === 'General') {
                        description = `${season} Pest ${topics[i % topics.length]} - ${formats[i % formats.length]}`;
                        keywords = `${seasonalKeyword} pest ${theme}`;
                    } else {
                        description = `${season} ${pestType} ${topics[i % topics.length]} - ${formats[i % formats.length]}`;
                        keywords = `${seasonalKeyword} ${pestType.toLowerCase()} ${theme}`;
                    }
                    
                    notes = 'Location-agnostic per Brad rules';
                    
                } else if (defaultContentType === 'Blog Post') {
                    // Blog posts can be location-specific
                    const locations = ['Dixon IL', 'Sycamore IL', 'Rockford IL', 'DeKalb IL'];
                    targetLocation = locationFocus ? (primaryLocation !== 'Illinois' ? primaryLocation : locations[i % locations.length]) : locations[i % locations.length];
                    contentFormat = 'WordPress Blog';
                    priority = targetLocation.includes('Dixon') || targetLocation.includes('Sycamore') ? 'HIGH' : 'MEDIUM';
                    
                    const blogTopics = [
                        'Complete Guide', 'Expert Solutions', 'Homeowner Guide', 'Seasonal Strategy',
                        'Professional Tips', 'Advanced Methods', 'Comprehensive Plan', 'Local Solutions'
                    ];
                    
                    if (pestType === 'General') {
                        description = `${targetLocation} ${season} Pest ${theme.charAt(0).toUpperCase() + theme.slice(1)} - ${blogTopics[i % blogTopics.length]}`;
                        keywords = `${seasonalKeyword} pest ${theme} ${targetLocation}`;
                    } else {
                        description = `${targetLocation} ${season} ${pestType} ${theme.charAt(0).toUpperCase() + theme.slice(1)} - ${blogTopics[i % blogTopics.length]}`;
                        keywords = `${seasonalKeyword} ${pestType.toLowerCase()} ${theme} ${targetLocation}`;
                    }
                    
                    notes = targetLocation.includes('Dixon') || targetLocation.includes('Sycamore') ? 'Office location priority' : 'Market expansion content';
                    
                } else {
                    // Location pages
                    const locations = ['Naperville IL', 'Wheaton IL', 'Aurora IL', 'Batavia IL'];
                    targetLocation = locations[i % locations.length];
                    contentFormat = 'Landing Page';
                    priority = 'MEDIUM';
                    
                    description = `${targetLocation} Pest Control Services`;
                    keywords = `pest control ${targetLocation}`;
                    notes = 'Local SEO expansion';
                }
                
                // Calculate realistic search volume based on location and pest type
                let searchVolume = 150;
                if (targetLocation.includes('Multi-State')) searchVolume = 500 + Math.floor(Math.random() * 300);
                else if (targetLocation.includes('Rockford') || targetLocation.includes('Aurora')) searchVolume = 300 + Math.floor(Math.random() * 200);
                else searchVolume = 100 + Math.floor(Math.random() * 150);
                
                const keywordDifficulty = searchVolume > 400 ? 'Medium' : searchVolume > 200 ? 'Low' : 'Low';
                
                generatedContent.push({
                    description: description,
                    contentType: defaultContentType,
                    priority: priority,
                    targetLocation: targetLocation,
                    pestType: pestType,
                    contentFormat: contentFormat,
                    seasonalRelevance: season,
                    primaryKeyword: keywords,
                    searchVolume: searchVolume,
                    keywordDifficulty: keywordDifficulty,
                    notes: notes
                });
            }
            
            console.log('Generated content:', generatedContent);
            return generatedContent;
        }

        // Drag-and-drop disabled; simple static table

        // Initialize FullCalendar
        // REMOVED: Calendar functionality (staging dashboard only)
        async function initializeCalendar() {
            console.log('📅 Calendar functionality disabled (staging dashboard)');
            return;
            
            // Fix: Use fullCalendarInstance to avoid conflict with DOM element id="calendar"
            window.fullCalendarInstance = new FullCalendar.Calendar(calendarEl, {
                initialView: 'dayGridMonth',
                headerToolbar: {
                    left: 'prev,next today',
                    center: 'title',
                    right: 'dayGridMonth,timeGridWeek,listWeek'
                },
                height: 600,
                editable: true,
                droppable: true,
                eventResizableFromStart: false,
                eventDurationEditable: false,
                dayMaxEvents: 3,
                moreLinkClick: 'popover',
                
                // Event sources
                events: function(info, successCallback, failureCallback) {
                    const events = convertContentToCalendarEvents();
                    successCallback(events);
                },
                
                // Drag and drop handling
                eventDrop: function(info) {
                    console.log('🔄 EventDrop triggered:', info.event.id, 'to', info.event.start);
                    const eventId = info.event.id;
                    const newDate = info.event.start.toISOString().split('T')[0];
                    
                    // Update content data - FIXED: Use window.contentData for all records including Airtable
                    const record = window.contentData.find(r => r.id === eventId);
                    console.log('📍 Found record for eventDrop:', !!record);
                    if (record) {
                        record.targetPublishDate = newDate;
                        record.modified_at = new Date().toISOString();
                        record.source = 'calendar';
                        
                        logStatus(`📅 Moved "${record.description}" to ${newDate}"`);
                        
                        // Update table view if visible
                        if (currentView === 'table') {
                            populateCards();
                        }
                        
                        // Update calendar stats
                        updateCalendarStats();
                        
                        // CRITICAL FIX: Save to Airtable if this is an Airtable record
                        if (record.id.startsWith('airtable_')) {
                            updateAirtableRecord(record, 'calendar drag-drop')
                                .then(() => {
                                    logStatus(`✅ Saved date change to Airtable: "${record.description}"`);
                                })
                                .catch(error => {
                                    logStatus(`❌ Failed to save to Airtable: ${error.message}`);
                                    console.error('Airtable update failed:', error);
                                });
                        }
                        
                        // Sync changes
                        syncToClaude();
                    }
                },
                
                // Handle external element drops (from table rows to calendar)
                drop: function(info) {
                    console.log('Calendar drop event triggered:', info);
                    
                    let recordId = null;
                    
                    // Try to get record ID from FullCalendar external drop
                    if (info.draggedEl && info.draggedEl.dataset.recordData) {
                        try {
                            const cachedRecord = JSON.parse(info.draggedEl.dataset.recordData);
                            recordId = cachedRecord.id;
                            console.log('Got record ID from FullCalendar external drop:', recordId);
                        } catch (error) {
                            console.error('Error parsing FullCalendar drop data:', error);
                        }
                    }
                    
                    // Try to get record ID from native HTML5 drop (fallback)
                    if (!recordId && info.jsEvent && info.jsEvent.dataTransfer) {
                        try {
                            const transferData = info.jsEvent.dataTransfer.getData('text/plain');
                            if (transferData) {
                                const cachedRecord = JSON.parse(transferData);
                                recordId = cachedRecord.id;
                                console.log('Got record ID from native HTML5 drop:', recordId);
                            }
                        } catch (error) {
                            console.error('Error parsing native drop data:', error);
                        }
                    }
                    
                    if (recordId) {
                        const dateStr = info.dateStr;
                        
                        // CRITICAL FIX: Always use current record data from contentData, not cached data
                        const existingRecord = window.contentData.find(r => r.id === recordId);
                        if (existingRecord) {
                            existingRecord.targetPublishDate = dateStr;
                            existingRecord.scheduledDate = dateStr;
                            
                            // Mark as user-modified to prevent polling overwrites
                            markUserModified(existingRecord, 'drag');
                            
                            logStatus(`📅 Scheduled: "${existingRecord.description.substring(0, 50)}..." on ${dateStr} (${existingRecord.contentType})`);
                            
                            // CRITICAL FIX: Save to Airtable if this is an Airtable record
                            if (existingRecord.id.startsWith('airtable_')) {
                                updateAirtableRecord(existingRecord, 'table to calendar drag')
                                    .then(() => {
                                        logStatus(`✅ Saved schedule to Airtable: "${existingRecord.description}"`);
                                    })
                                    .catch(error => {
                                        logStatus(`❌ Failed to save to Airtable: ${error.message}`);
                                        console.error('Airtable update failed:', error);
                                    });
                            }
                            
                            // Refresh calendar and table
                            // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                            populateCards();
                            updateCalendarStats();
                        } else {
                            logStatus(`❌ Record not found: ${recordId}`);
                        }
                    } else {
                        logStatus(`❌ No record ID found in drop event`);
                        console.log('Drop info details:', info);
                    }
                },
                
                // Event click handling
                eventClick: function(info) {
                    console.log('Calendar event clicked!', info.event.id);
                    const eventId = info.event.id;
                    const record = window.contentData.find(r => r.id === eventId);
                    
                    console.log('Found record:', record);
                    
                    if (record) {
                        // Check if right-click (context menu)
                        if (info.jsEvent.button === 2) {
                            info.jsEvent.preventDefault();
                            
                            if (confirm(`Delete "${record.description}"?`)) {
                                deleteRow(eventId);
                                return;
                            }
                        } else {
                            // Left click - show content details card
                            console.log('Calling showContentDetailsCard with record:', record.description);
                            showContentDetailsCard(record);
                        }
                    } else {
                        console.log('No record found for event ID:', eventId);
                        console.log('Available contentData IDs:', window.contentData.map(r => r.id));
                    }
                },
                
                // Date click - create new content
                dateClick: function(info) {
                    if (editMode) {
                        createContentForDate(info.dateStr);
                    }
                },
                
                // Custom event rendering
                eventDidMount: function(info) {
                    const record = window.contentData.find(r => r.id === info.event.id);
                    if (record) {
                        // Add content type and priority classes
                        const contentTypeClass = `content-${(record.contentType || 'Blog Post').toLowerCase().replace(/\s+/g, '-')}`;
                        const priorityClass = `priority-${record.priority || 'MEDIUM'}`;
                        
                        info.el.classList.add(contentTypeClass);
                        info.el.classList.add(priorityClass);
                        
                        // Add selection indicator
                        if (record.selected) {
                            info.el.style.outline = '2px solid var(--primary-green)';
                            info.el.style.outlineOffset = '2px';
                            info.el.style.transform = 'scale(1.02)';
                        }
                        
                        // Add tooltip with modern content
                        info.el.title = `📝 ${record.description}\n🎯 Type: ${record.contentType}\n⚡ Priority: ${record.priority}\n📍 Location: ${record.targetLocation}\n🐛 Pest: ${record.pestType}`;
                        
                        // Add modern hover effects
                        info.el.style.transition = 'all 0.2s ease';
                    }
                }
            });
            
            // Render the calendar
            try {
                // window.fullCalendarInstance.render(); // Calendar disabled
                console.log('✅ Calendar initialized successfully');
                logStatus('✅ Calendar ready for drag-drop');
            } catch (error) {
                console.error('❌ Calendar render failed:', error);
                logStatus(`❌ Calendar error: ${error.message}`);
            }
        }

        // Convert content data to calendar events
        // Calculate routing score based on {{CLIENT_NAME}} decision framework
        function calculateRoutingScore(item) {
            let score = 0;
            
            // Images/Graphics required? (+2 → Systematic)
            if (item.contentType === 'Social Media' || 
                (item.description && item.description.toLowerCase().includes('graphic')) ||
                (item.description && item.description.toLowerCase().includes('image')) ||
                (item.notes && item.notes.toLowerCase().includes('visual'))) {
                score += 2;
            }
            
            // Search volume >500/month? (+2 → Systematic)
            const volume = parseInt(item.searchVolume) || 0;
            if (volume > 500) {
                score += 2;
            }
            
            // Urgent same-day need? (+2 → Local)
            const publishDate = new Date(item.targetPublishDate || '');
            const today = new Date();
            const diffDays = Math.ceil((publishDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
            if (diffDays <= 1 && diffDays >= 0) {
                score -= 2; // Subtract to favor LOCAL
            }
            
            // Standard format content? (+1 → Systematic) 
            if (item.contentType === 'Blog Post' || item.contentType === 'Location Page') {
                score += 1;
            }
            
            // Complex strategy required? (+2 → Local)
            if (item.description && (
                item.description.toLowerCase().includes('strategy') ||
                item.description.toLowerCase().includes('research') ||
                item.description.toLowerCase().includes('analysis') ||
                item.description.toLowerCase().includes('brief')
            )) {
                score -= 2; // Subtract to favor LOCAL
            }
            
            // Bulk production (5+ pieces)? (+2 → Systematic)
            // This would need to be calculated at a higher level, skip for now
            
            return Math.max(0, score); // Don't allow negative scores
        }

        function convertContentToCalendarEvents() {
            console.log('Calendar events disabled (staging dashboard)');
            return [];
            
            // DISABLED: Calendar event conversion
            /*
            return window.contentData
                .filter(record => getPublishDate(record))
                .map(record => {
                    const contentTypeClass = `content-${(record.contentType || 'Blog Post').toLowerCase().replace(/\s+/g, '-')}`;
                    const priorityClass = `priority-${record.priority || 'MEDIUM'}`;
                    const publishDate = getPublishDate(record);
                    
                    return {
                        id: record.id,
                        title: record.description,
                        start: publishDate,
                        allDay: true,
                        classNames: [
                            contentTypeClass,
                            priorityClass
                        ],
                        extendedProps: {
                            contentType: record.contentType,
                            priority: record.priority,
                            targetLocation: record.targetLocation,
                            pestType: record.pestType,
                            selected: record.selected
                        }
                    };
                });
            */
        }

        // Update calendar event appearance
        function updateCalendarEventAppearance(event, record) {
            const eventEl = event.el;
            if (record.selected) {
                eventEl.style.border = '2px solid #fff';
                eventEl.style.boxShadow = '0 0 0 2px #2c5530';
            } else {
                eventEl.style.border = '';
                eventEl.style.boxShadow = '';
            }
        }

        // Create new content for a specific date with full infrastructure
        // Show content creation modal for date
        function createContentForDate(dateStr) {
            // Store the date for later use
            window.selectedContentDate = dateStr;
            
            // Update modal date display
            const modalDateText = document.getElementById('modalDateText');
            const date = new Date(dateStr);
            const formattedDate = date.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            modalDateText.textContent = `Publishing date: ${formattedDate}`;
            
            // Reset form
            document.getElementById('contentForm').reset();
            
            // Show modal
            const modal = document.getElementById('contentModal');
            modal.classList.add('active');
            
            // Focus on description field
            setTimeout(() => {
                document.getElementById('contentDescription').focus();
            }, 100);
        }
        
        // Close content creation modal
        function closeContentModal() {
            const modal = document.getElementById('contentModal');
            modal.classList.remove('active');
            window.selectedContentDate = null;
        }
        
        // Create content from modal form
        async function createContentFromModal() {
            const form = document.getElementById('contentForm');
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }
            
            const createBtn = document.getElementById('createBtn');
            const originalText = createBtn.innerHTML;
            
            // Disable button and show loading
            createBtn.disabled = true;
            createBtn.innerHTML = '⏳ Creating...';
            
            try {
                // Get form data
                const contentData = {
                    description: document.getElementById('contentDescription').value,
                    contentType: document.getElementById('contentType').value,
                    priority: document.getElementById('contentPriority').value,
                    targetLocation: document.getElementById('targetLocation').value,
                    pestType: document.getElementById('pestType').value,
                    keywords: document.getElementById('primaryKeywords').value,
                    notes: document.getElementById('contentNotes').value,
                    targetPublishDate: window.selectedContentDate,
                    productionMethod: 'Local'
                };
                
                // Create full infrastructure (Airtable + Google Drive)
                logStatus('🚀 Setting up content infrastructure...');
                const infrastructure = await createContentWithInfrastructure(contentData);
                
                // Add to local display with full infrastructure data
                const newRecord = {
                    id: `local_${Date.now()}`,
                    airtableId: infrastructure.recordId,
                    folderId: infrastructure.folderId,
                    folderLink: infrastructure.folderLink,
                    folderName: infrastructure.folderName,
                    description: contentData.description,
                    contentType: contentData.contentType,
                    priority: contentData.priority,
                    productionMethod: contentData.productionMethod,
                    targetLocation: contentData.targetLocation || 'Multi-State',
                    pestType: contentData.pestType || 'General',
                    contentFormat: 'WordPress Blog',
                    seasonalRelevance: 'Year-Round',
                    primaryKeyword: contentData.keywords,
                    targetPublishDate: window.selectedContentDate,
                    searchVolume: 0,
                    keywordDifficulty: 'Low',
                    generationType: 'LOCAL',
                    notes: contentData.notes,
                    selected: true,
                    order: window.contentData.length,
                    source: 'calendar-infrastructure',
                    infrastructureReady: true,
                    created_at: new Date().toISOString(),
                    modified_at: new Date().toISOString()
                };
                
                window.contentData.push(newRecord);
                
                // Refresh views
                populateCards();
                if (calendar) {
                    // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                    updateCalendarStats();
                }
                
                logStatus(`🎉 Content infrastructure ready for ${window.selectedContentDate}: ${infrastructure.folderName}`);
                syncToClaude();
                
                // Close modal
                closeContentModal();
                
            } catch (error) {
                logStatus(`❌ Failed to create content infrastructure: ${error.message}`);
                console.error('Content infrastructure creation error:', error);
                
                // Re-enable button
                createBtn.disabled = false;
                createBtn.innerHTML = originalText;
            }
        }
        
        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('contentModal');
            if (e.target === modal) {
                closeContentModal();
            }
        });
        
        // Close modal with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeContentModal();
            }
        });


        // Legacy function for compatibility (DISABLED - unified layout)
        function toggleCalendarPanel() {
            // Legacy function disabled - calendar is always visible in unified layout
            console.log('toggleCalendarPanel: Legacy function disabled in unified layout');
        }

        // Switch between planning session and timeline view (updated for collapsible sections)
        function switchPlanningView(view) {
            currentView = view;
            
            // Get the collapsible sections
            const planningSection = document.getElementById('planningSection');
            const timelineSection = document.getElementById('timelineSection');
            const tableSummaryStats = document.getElementById('tableSummaryStats');
            const tableBtn = document.getElementById('tableViewBtn');
            const calendarBtn = document.getElementById('calendarViewBtn');
            
            if (view === 'calendar') {
                // In unified layout, both planning and calendar are always visible
                // No section collapse/expand needed
                
                // Hide table summary stats
                if (tableSummaryStats) tableSummaryStats.style.display = 'none';
                
                // Update button states
                if (tableBtn) tableBtn.classList.remove('active');
                if (calendarBtn) calendarBtn.classList.add('active');
                
                // Calendar is always visible in unified layout - just refresh if needed
                if (false) { // Calendar disabled
                    // window.fullCalendarInstance.render(); // Calendar disabled
                    // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                    updateCalendarStats();
                }
                
                logStatus('📅 Switched to Timeline View');
                
            } else {
                // Expand planning section, optionally collapse timeline
                planningSection.classList.remove('collapsed');
                // Note: We don't auto-collapse timeline - user can manage both sections
                
                // Show table summary stats
                if (tableSummaryStats) tableSummaryStats.style.display = 'grid';
                
                // Update button states
                if (tableBtn) tableBtn.classList.add('active');
                if (calendarBtn) calendarBtn.classList.remove('active');
                
                // Update table stats
                updateSummaryStats();
                
                logStatus('📝 Switched to Planning View');
            }
        }

        // Change calendar view (month/week/list)
        function changeCalendarView(viewName) {
            console.log('Calendar view change disabled (staging dashboard)');
            return;
            
            // DISABLED: Update button states
            document.querySelectorAll('.calendar-view-btn').forEach(btn => btn.classList.remove('active'));
            
            if (viewName === 'dayGridMonth') {
                document.getElementById('monthViewBtn').classList.add('active');
            } else if (viewName === 'timeGridWeek') {
                document.getElementById('weekViewBtn').classList.add('active');
            } else if (viewName === 'listWeek') {
                document.getElementById('listViewBtn').classList.add('active');
            }
            
            logStatus(`📅 Calendar view changed to ${viewName}`);
        }

        // Navigate to today in calendar
        function todayCalendar() {
            // window.fullCalendarInstance.today(); // Calendar disabled
            logStatus('📍 Calendar navigated to today');
        }

        // Update calendar statistics (All content sources: Claude Code + Airtable)
        // Helper function to get publish date from any record format
        function getPublishDate(record) {
            return record.targetPublishDate || record.scheduledDate || record['Publish Date'] || null;
        }
        
        function updateCalendarStats() {
            console.log('Calendar stats disabled (staging dashboard)');
            return;
            
            // DISABLED: Count all content with publish dates
            // const withDates = window.contentData.filter(r => getPublishDate(r)).length;
            // const highPriority = window.contentData.filter(r => r.priority === 'HIGH' && getPublishDate(r)).length;
            
            // Calculate content for the currently displayed month in calendar
            const calendarDate = new Date(); // Calendar disabled - use current date
            const displayedMonth = window.contentData.filter(r => {
                const publishDate = getPublishDate(r);
                if (!publishDate) return false;
                const date = new Date(publishDate);
                return date.getMonth() === calendarDate.getMonth() && date.getFullYear() === calendarDate.getFullYear();
            }).length;
            
            // Calculate upcoming (next 7 days from today)
            const now = new Date();
            const upcoming = window.contentData.filter(r => {
                const publishDate = getPublishDate(r);
                if (!publishDate) return false;
                const date = new Date(publishDate);
                const diffTime = date.getTime() - now.getTime();
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                return diffDays >= 0 && diffDays <= 7;
            }).length;
            
            // Update calendar stats
            document.getElementById('calendarTotalContent').textContent = withDates;
            document.getElementById('calendarThisMonth').textContent = displayedMonth;
            document.getElementById('calendarHighPriority').textContent = highPriority;
            document.getElementById('calendarUpcoming').textContent = upcoming;
        }

        // Populate the content cards (LOCAL planning content only - exclude Airtable items)
        function populateCardsOLD_DISABLED() {
            console.log('🔄 populateCardsOLD_DISABLED() called - OLD TABLE VERSION DISABLED');
            return; // DISABLED: This is the old table-based version
            
            const cardsContainer = document.getElementById('cardsContainer');
            const emptyState = document.getElementById('cardsEmptyState');
            
            console.log('populateCards called, contentData:', window.contentData?.length, 'items');
            
            // Filter to only show LOCAL planning content (exclude Airtable items from cards view)
            // Include: claude source, calendar source, missing source field (legacy/restored), or LOCAL generation type
            const cardsData = window.contentData ? window.contentData.filter(item => 
                item.source === 'claude' || 
                item.source === 'calendar' ||
                !item.source || 
                (item.generationType === 'LOCAL' && item.source !== 'airtable')
            ) : [];
            
            console.log('Cards filtering: showing', cardsData.length, 'LOCAL planning items (excluding', 
                       (window.contentData?.length || 0) - cardsData.length, 'Airtable items)');
            
            // Clear existing cards
            cardsContainer.innerHTML = '';
            
            if (cardsData.length === 0) {
                console.log('No LOCAL planning content, showing empty state');
                emptyState.style.display = 'block';
                return;
            } else {
                emptyState.style.display = 'none';
            }
            
            console.log('Rendering cards with', cardsData.length, 'LOCAL planning items');
            
            cardsData.forEach((item, index) => {
                const row = document.createElement('tr');
                const contentTypeClass = `type-${(item.contentType || 'Blog Post').toLowerCase().replace(/\s+/g, '-')}`;
                const userModifiedClass = item.userModified && isRecentlyUserModified(item) ? 'user-modified' : '';
                row.className = `content-row ${item.selected ? 'selected' : ''} ${contentTypeClass} ${userModifiedClass}`.trim();
                row.dataset.id = item.id;
                
                // Add draggable class for planning records (only claude source items)
                if (item.source === 'claude') {
                    row.classList.add('draggable-planning-item');
                    row.dataset.recordData = JSON.stringify(item);
                    
                    // Add native HTML5 draggable as fallback
                    row.draggable = true;
                    row.addEventListener('dragstart', function(e) {
                        // CRITICAL FIX: Use current record data from contentData, not cached item
                        const currentRecord = window.contentData.find(r => r.id === item.id);
                        if (currentRecord) {
                            console.log('Native dragstart triggered for:', currentRecord.description.substring(0, 50), `(${currentRecord.contentType})`);
                            e.dataTransfer.setData('text/plain', JSON.stringify(currentRecord));
                            e.dataTransfer.effectAllowed = 'move';
                            row.style.opacity = '0.5';
                            logStatus(`📦 Dragging: ${currentRecord.description.substring(0, 50)}... (${currentRecord.contentType})`);
                        } else {
                            console.warn('Current record not found for drag:', item.id);
                            e.dataTransfer.setData('text/plain', JSON.stringify(item));
                            e.dataTransfer.effectAllowed = 'move';
                            row.style.opacity = '0.5';
                            logStatus(`📦 Dragging: ${item.description.substring(0, 50)}... (fallback)`);
                        }
                    });
                    
                    row.addEventListener('dragend', function(e) {
                        console.log('Native dragend triggered');
                        row.style.opacity = '';
                    });
                }
                
                // Add generation type indicator
                const genTypeIcon = item.generationType === 'LOCAL' ? '📝' : '🚀';
                const genTypeClass = item.generationType === 'LOCAL' ? 'gen-local' : 'gen-systematic';
                
                // Create schedule status + drag handle cell (first column)
                const rowIndicatorCell = document.createElement('td');
                const isScheduled = item.scheduledDate || item.targetPublishDate;
                const isUserModified = item.userModified && isRecentlyUserModified(item);
                
                let statusIcon = isScheduled ? '📅' : '⋮⋮';
                let statusTitle = isScheduled ? `Scheduled: ${isScheduled}` : 'Drag to calendar to schedule';
                let statusColor = isScheduled ? 'var(--primary-green)' : '#666';
                
                // Show user modification indicator
                if (isUserModified) {
                    statusIcon = '✏️'; // Edit indicator
                    statusTitle = `Modified by user ${item.userAction || 'recently'} - protected from polling overwrites`;
                    statusColor = '#ff6b35'; // Orange color for user modifications
                }
                
                rowIndicatorCell.innerHTML = `<span class="drag-handle status-indicator" 
                    style="cursor: grab; color: ${statusColor}; user-select: none; font-size: 14px; pointer-events: none;" 
                    title="${statusTitle}">${statusIcon}</span>`;
                rowIndicatorCell.style.textAlign = 'center';
                row.appendChild(rowIndicatorCell);
                
                const checkboxCell = document.createElement('td');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'row-checkbox';
                checkbox.checked = item.selected;
                checkbox.onchange = () => toggleRowSelection(item.id, checkbox.checked);
                checkboxCell.appendChild(checkbox);
                row.appendChild(checkboxCell);
                
                const descCell = document.createElement('td');
                const descInput = document.createElement('input');
                descInput.type = 'text';
                descInput.className = 'editable-cell';
                descInput.value = item.description || '';
                descInput.readOnly = !editMode;
                console.log('DEBUG: Setting description input readOnly to', !editMode, 'editMode is', editMode);
                console.log('DEBUG: Description input element:', descInput, 'disabled:', descInput.disabled, 'readOnly:', descInput.readOnly);
                
                // Add click and focus event debugging
                descInput.addEventListener('click', (e) => {
                    console.log('DEBUG: Description input clicked!', 'editMode:', editMode, 'readOnly:', e.target.readOnly, 'disabled:', e.target.disabled);
                });
                descInput.addEventListener('focus', (e) => {
                    console.log('DEBUG: Description input focused!', 'editMode:', editMode, 'readOnly:', e.target.readOnly, 'disabled:', e.target.disabled);
                });
                
                // Prevent drag events from interfering with text editing
                preventDragInterference(descInput);
                
                descInput.onchange = () => {
                    console.log('DEBUG: Description field changed!', descInput.value);
                    updateField(item.id, 'description', descInput.value);
                };
                descCell.appendChild(descInput);
                row.appendChild(descCell);
                
                const typeCell = document.createElement('td');
                const typeSelect = document.createElement('select');
                typeSelect.className = 'editable-cell';
                typeSelect.disabled = !editMode;
                console.log('DEBUG: Setting content type select disabled to', !editMode, 'editMode is', editMode);
                console.log('DEBUG: Content type select element:', typeSelect, 'disabled:', typeSelect.disabled);
                
                // Add debugging for select interactions
                typeSelect.addEventListener('click', (e) => {
                    console.log('DEBUG: Content type select clicked!', 'editMode:', editMode, 'disabled:', e.target.disabled);
                });
                typeSelect.addEventListener('focus', (e) => {
                    console.log('DEBUG: Content type select focused!', 'editMode:', editMode, 'disabled:', e.target.disabled);
                });
                
                // Prevent drag events from interfering with select interactions
                preventDragInterference(typeSelect);
                
                typeSelect.innerHTML = `
                    <option value="Blog Post" ${item.contentType === 'Blog Post' ? 'selected' : ''}>Blog Post</option>
                    <option value="Social Media" ${item.contentType === 'Social Media' ? 'selected' : ''}>Social Media</option>
                    <option value="Location Page" ${item.contentType === 'Location Page' ? 'selected' : ''}>Location Page</option>
                    <option value="Location Service Page" ${item.contentType === 'Location Service Page' ? 'selected' : ''}>Location Service Page</option>
                    <option value="Email Campaign" ${item.contentType === 'Email Campaign' ? 'selected' : ''}>Email Campaign</option>
                    <option value="Video Script" ${item.contentType === 'Video Script' ? 'selected' : ''}>Video Script</option>
                `;
                typeSelect.onchange = () => updateField(item.id, 'contentType', typeSelect.value);
                typeCell.appendChild(typeSelect);
                row.appendChild(typeCell);
                
                const priorityCell = document.createElement('td');
                const prioritySelect = document.createElement('select');
                prioritySelect.className = `priority-select priority-${item.priority}`;
                prioritySelect.disabled = !editMode;
                prioritySelect.innerHTML = `
                    <option value="HIGH" ${item.priority === 'HIGH' ? 'selected' : ''}>HIGH</option>
                    <option value="MEDIUM" ${item.priority === 'MEDIUM' ? 'selected' : ''}>MED</option>
                    <option value="LOW" ${item.priority === 'LOW' ? 'selected' : ''}>LOW</option>
                `;
                prioritySelect.onchange = () => updateField(item.id, 'priority', prioritySelect.value);
                priorityCell.appendChild(prioritySelect);
                row.appendChild(priorityCell);
                
                const locationCell = document.createElement('td');
                const locationInput = document.createElement('input');
                locationInput.type = 'text';
                locationInput.className = 'editable-cell';
                locationInput.value = item.targetLocation || item.location || '';
                locationInput.readOnly = !editMode;
                preventDragInterference(locationInput);
                locationInput.onchange = () => updateField(item.id, 'targetLocation', locationInput.value);
                locationCell.appendChild(locationInput);
                row.appendChild(locationCell);
                
                const pestCell = document.createElement('td');
                const pestInput = document.createElement('input');
                pestInput.type = 'text';
                pestInput.className = 'editable-cell';
                pestInput.value = item.pestType || '';
                pestInput.readOnly = !editMode;
                preventDragInterference(pestInput);
                pestInput.onchange = () => updateField(item.id, 'pestType', pestInput.value);
                pestCell.appendChild(pestInput);
                row.appendChild(pestCell);
                
                const keywordCell = document.createElement('td');
                const keywordInput = document.createElement('input');
                keywordInput.type = 'text';
                keywordInput.className = 'editable-cell';
                keywordInput.value = item.primaryKeyword || item.keywords || '';
                keywordInput.readOnly = !editMode;
                preventDragInterference(keywordInput);
                keywordInput.onchange = () => updateField(item.id, 'primaryKeyword', keywordInput.value);
                keywordCell.appendChild(keywordInput);
                row.appendChild(keywordCell);
                
                const volumeCell = document.createElement('td');
                const volumeInput = document.createElement('input');
                volumeInput.type = 'number';
                volumeInput.className = 'editable-cell';
                volumeInput.value = item.searchVolume || '';
                volumeInput.readOnly = !editMode;
                preventDragInterference(volumeInput);
                volumeInput.onchange = () => updateField(item.id, 'searchVolume', parseInt(volumeInput.value));
                volumeCell.appendChild(volumeInput);
                row.appendChild(volumeCell);
                
                const difficultyCell = document.createElement('td');
                const difficultySelect = document.createElement('select');
                difficultySelect.className = 'editable-cell';
                difficultySelect.disabled = !editMode;
                preventDragInterference(difficultySelect);
                difficultySelect.innerHTML = `
                    <option value="Low" ${item.keywordDifficulty === 'Low' ? 'selected' : ''}>Low</option>
                    <option value="Medium" ${item.keywordDifficulty === 'Medium' ? 'selected' : ''}>Med</option>
                    <option value="High" ${item.keywordDifficulty === 'High' ? 'selected' : ''}>High</option>
                `;
                difficultySelect.onchange = () => updateField(item.id, 'keywordDifficulty', difficultySelect.value);
                difficultyCell.appendChild(difficultySelect);
                row.appendChild(difficultyCell);
                
                const genTypeCell = document.createElement('td');
                const genTypeSelect = document.createElement('select');
                genTypeSelect.className = `editable-cell ${genTypeClass}`;
                genTypeSelect.disabled = !editMode;
                preventDragInterference(genTypeSelect);
                genTypeSelect.innerHTML = `
                    <option value="LOCAL" ${(item.generationType || 'LOCAL') === 'LOCAL' ? 'selected' : ''}>📝 Local</option>
                    <option value="SYSTEMATIC" ${(item.generationType || 'LOCAL') === 'SYSTEMATIC' ? 'selected' : ''}>🚀 System</option>
                `;
                genTypeSelect.onchange = () => updateField(item.id, 'generationType', genTypeSelect.value);
                genTypeCell.appendChild(genTypeSelect);
                row.appendChild(genTypeCell);
                
                // Add scoring cell with routing calculation
                const scoreCell = document.createElement('td');
                try {
                    const score = calculateRoutingScore ? calculateRoutingScore(item) : 0;
                    const recommendation = score >= 4 ? 'SYSTEMATIC' : 'LOCAL';
                    const scoreColor = score >= 4 ? '#dc3545' : '#28a745';
                    scoreCell.innerHTML = `<span style="color: ${scoreColor}; font-weight: bold;" title="Routing Score: ${score} → ${recommendation}">${score}</span>`;
                } catch (error) {
                    console.error('Scoring error:', error, item);
                    scoreCell.innerHTML = '<span style="color: #666;" title="Scoring unavailable">?</span>';
                }
                row.appendChild(scoreCell);
                
                const dateCell = document.createElement('td');
                const dateInput = document.createElement('input');
                dateInput.type = 'date';
                dateInput.className = 'editable-cell';
                dateInput.value = item.targetPublishDate || '';
                dateInput.readOnly = !editMode;
                preventDragInterference(dateInput);
                dateInput.onchange = () => updateField(item.id, 'targetPublishDate', dateInput.value);
                dateCell.appendChild(dateInput);
                row.appendChild(dateCell);
                
                const actionsCell = document.createElement('td');
                const duplicateBtn = document.createElement('button');
                duplicateBtn.className = 'control-btn';
                duplicateBtn.title = 'Duplicate';
                duplicateBtn.innerHTML = '📋';
                duplicateBtn.onclick = () => duplicateRow(item.id);
                actionsCell.appendChild(duplicateBtn);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'control-btn';
                deleteBtn.title = 'Delete';
                deleteBtn.innerHTML = '🗑️';
                deleteBtn.onclick = () => deleteRow(item.id);
                actionsCell.appendChild(deleteBtn);
                
                if (item.generationType === 'LOCAL') {
                    const fileBtn = document.createElement('button');
                    fileBtn.className = 'control-btn';
                    fileBtn.title = 'Create MD File';
                    fileBtn.innerHTML = '📝';
                    fileBtn.onclick = () => createLocalFile(item.id);
                    actionsCell.appendChild(fileBtn);
                }
                row.appendChild(actionsCell);
                
                tbody.appendChild(row);
            });
            
            updateEmptyState();
            updateSummaryStats();
            
            // Re-initialize external draggable after table update
            setTimeout(() => {
                initializeExternalDraggable();
            }, 100);
            updateCommitButton();
            
            // Refresh calendar if it exists
            if (false) { // Calendar disabled
                try {
                    // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                    updateCalendarStats();
                } catch (error) {
                    console.error('Error refreshing calendar:', error);
                }
            }
        }

        // NEW: Populate the content cards (LOCAL planning content only - exclude Airtable items)
        function populateCards() {
            console.log('🔄 populateCards() called - rebuilding content cards');
            const cardsContainer = document.getElementById('cardsContainer');
            let emptyState = document.getElementById('cardsEmptyState');
            
            // CRITICAL: DOM element validation
            if (!cardsContainer) {
                console.error('CRITICAL: cardsContainer not found');
                logStatus('❌ Cards view unavailable - cardsContainer missing');
                return;
            }
            
            // Create missing emptyState element if needed
            if (!emptyState) {
                console.log('🔧 Creating missing cardsEmptyState element...');
                emptyState = document.createElement('div');
                emptyState.className = 'cards-empty-state';
                emptyState.id = 'cardsEmptyState';
                emptyState.innerHTML = `
                    <div class="icon">📋</div>
                    <h4>No Content Staged Yet</h4>
                    <p>Sync from Claude Code to get started</p>
                `;
                cardsContainer.appendChild(emptyState);
                console.log('✅ cardsEmptyState element created');
            }
            
            console.log('populateCards called, contentData:', window.contentData?.length, 'items');
            console.log('📊 DEBUG: Raw contentData:', window.contentData);
            
            // Debug each record's properties
            if (window.contentData && window.contentData.length > 0) {
                window.contentData.forEach((item, index) => {
                    console.log(`📊 DEBUG Record ${index}:`, {
                        id: item.id,
                        title: item.title,
                        source: item.source,
                        generationType: item.generationType,
                        willShow: (item.source === 'claude' || 
                                  item.source === 'calendar' ||
                                  !item.source || 
                                  (item.generationType === 'LOCAL' && item.source !== 'airtable'))
                    });
                });
            }
            
            // Filter to only show LOCAL planning content (exclude Airtable items from cards view)
            // Include: claude source, calendar source, missing source field (legacy/restored), or LOCAL generation type
            const cardsData = window.contentData ? window.contentData.filter(item => 
                item.source === 'claude' || 
                item.source === 'calendar' ||
                !item.source || 
                (item.generationType === 'LOCAL' && item.source !== 'airtable')
            ) : [];
            
            console.log('Cards filtering: showing', cardsData.length, 'LOCAL planning items (excluding', 
                       (window.contentData?.length || 0) - cardsData.length, 'Airtable items)');
            
            // Clear existing cards
            cardsContainer.innerHTML = '';
            
            if (cardsData.length === 0) {
                console.log('No LOCAL planning content, showing empty state');
                emptyState.style.display = 'block';
                return;
            } else {
                emptyState.style.display = 'none';
            }
            
            console.log('Rendering cards with', cardsData.length, 'LOCAL planning items');
            
            // Create cards for each item
            cardsData.forEach((item, index) => {
                const card = createContentCard(item);
                cardsContainer.appendChild(card);
            });
            
            updateCardsSummaryStats();
            
            // Re-initialize external draggable after cards update
            setTimeout(() => {
                initializeCardDraggable();
            }, 100);
            updateCommitButton();
            
            // Refresh calendar if it exists
            if (false) { // Calendar disabled
                try {
                    // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                    updateCalendarStats();
                } catch (error) {
                    console.error('Error refreshing calendar:', error);
                }
            }
        }

        // Create a content card element
        function createContentCard(item) {
            const card = document.createElement('div');
            card.className = 'content-card';
            card.dataset.id = item.id;
            
            // Add selection styling
            if (item.selected) {
                card.classList.add('selected');
            }
            
            // Add submitted styling
            if (item.submitted) {
                card.classList.add('submitted');
            }
            
            // Add draggable functionality for claude source items (but not if submitted)
            if (item.source === 'claude' && !item.submitted) {
                card.classList.add('draggable-planning-item');
                card.dataset.recordData = JSON.stringify(item);
                card.draggable = true;
                
                card.addEventListener('dragstart', function(e) {
                    const currentRecord = window.contentData.find(r => r.id === item.id);
                    if (currentRecord) {
                        console.log('Card dragstart triggered for:', currentRecord.description.substring(0, 50));
                        e.dataTransfer.setData('text/plain', JSON.stringify(currentRecord));
                        e.dataTransfer.effectAllowed = 'move';
                        
                        // Create a proper drag image
                        const dragImage = createDragImage(currentRecord);
                        e.dataTransfer.setDragImage(dragImage, 0, 0);
                        
                        card.classList.add('dragging');
                        logStatus(`📦 Dragging: ${currentRecord.description.substring(0, 50)}...`);
                    }
                });
                
                card.addEventListener('dragend', function(e) {
                    card.classList.remove('dragging');
                });
            }
            
            // Determine workflow status
            const isScheduled = item.scheduledDate || item.targetPublishDate;
            const isCommitted = item.source === 'airtable' || item.airtableRecordId;
            let workflowStatus = 'staged';
            let statusText = 'Staged';
            let statusIcon = '🎯';
            
            if (isCommitted) {
                workflowStatus = 'committed';
                statusText = 'Committed';
                statusIcon = '📋';
            } else if (item.selected) {
                workflowStatus = 'ready';
                statusText = 'Ready';
                statusIcon = '✅';
            }
            
            // Get content type class for badge
            const contentTypeClass = getContentTypeClass(item.contentType || 'Blog Post');
            
            // Get priority class for badge
            const priorityClass = `priority-${(item.priority || 'MEDIUM').toLowerCase()}`;
            
            // Get generation method display info
            const generationType = item.generationType || 'LOCAL';
            const generationIcon = generationType === 'LOCAL' ? '📝' : '🚀';
            const generationText = generationType === 'LOCAL' ? 'Local' : 'Systematic';
            const generationClass = `generation-${generationType.toLowerCase()}`;
            
            // Enhanced generation status for LOCAL content
            const generationStatus = item.generationStatus || 'ready';
            const hasGeneratedContent = item.textContent && item.textContent.length > 0;
            const wordCount = item.wordCount || 0;
            
            // Get generation status display
            let genStatusIcon = '⏳';
            let genStatusText = 'Pending';
            let genStatusClass = 'gen-pending';
            
            if (generationType === 'SYSTEMATIC') {
                genStatusIcon = '🚀';
                genStatusText = 'N8N Ready';
                genStatusClass = 'gen-systematic';
            } else if (generationStatus === 'generated' && hasGeneratedContent) {
                genStatusIcon = '✅';
                genStatusText = `Generated (${wordCount} words)`;
                genStatusClass = 'gen-complete';
            } else if (generationStatus === 'failed') {
                genStatusIcon = '❌';
                genStatusText = 'Failed';
                genStatusClass = 'gen-failed';
            }
            
            // Build content preview section
            let contentPreviewHTML = '';
            if (hasGeneratedContent && item.contentPreview) {
                contentPreviewHTML = `
                    <div class="content-preview-section">
                        <div class="content-preview-header">
                            <span class="preview-label">📄 Generated Content Preview</span>
                            <button class="preview-expand-btn" onclick="expandContentPreview('${item.id}')" title="View full content">🔍 View Full</button>
                        </div>
                        <div class="content-preview-text">${item.contentPreview}</div>
                    </div>
                `;
            }
            
            card.innerHTML = `
                <div class="card-header">
                    <input type="checkbox" class="card-checkbox" ${item.selected ? 'checked' : ''} 
                           ${item.submitted ? 'disabled' : ''}
                           onchange="toggleRowSelection('${item.id}', this.checked)">
                    <div class="card-status status-${workflowStatus}">
                        <span>${statusIcon}</span>
                        <span>${statusText}</span>
                    </div>
                </div>
                
                <div class="card-description">${item.description || ''}</div>
                
                <div class="card-badges">
                    <span class="content-type-badge ${contentTypeClass}">${item.contentType || 'Blog Post'}</span>
                    <span class="priority-badge ${priorityClass}">${item.priority || 'MEDIUM'}</span>
                    <span class="generation-badge ${generationClass}" title="Generation Method: ${generationType}">${generationIcon} ${generationText}</span>
                    <span class="generation-status-badge ${genStatusClass}" title="Generation Status">${genStatusIcon} ${genStatusText}</span>
                </div>
                
                ${contentPreviewHTML}
                
                <div class="card-meta">
                    <div class="meta-item">
                        <div class="meta-label">Location</div>
                        <div class="meta-value">${item.targetLocation || item.location || 'Multi-State'}</div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">Pest Type</div>
                        <div class="meta-value">${item.pestType || 'General'}</div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">Search Volume</div>
                        <div class="meta-value">${item.searchVolume || '0'}</div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">Keywords</div>
                        <div class="meta-value">${truncateText(item.keywords || item.primaryKeyword || '', 30)}</div>
                    </div>
                    ${generationType === 'LOCAL' && hasGeneratedContent ? `
                    <div class="meta-item">
                        <div class="meta-label">Content ID</div>
                        <div class="meta-value">${item.contentId || 'Not assigned'}</div>
                    </div>` : ''}
                </div>
                
                <div class="card-actions">
                    <button class="card-edit-btn" onclick="editCardContent('${item.id}')">✏️ Edit</button>
                    ${hasGeneratedContent ? `<button class="card-preview-btn" onclick="previewGeneratedContent('${item.id}')" title="Preview generated content">👁️ Preview</button>` : ''}
                    <div class="card-drag-handle">⋮⋮</div>
                </div>
            `;
            
            return card;
        }

        // Helper function to get content type CSS class
        function getContentTypeClass(contentType) {
            const typeMap = {
                'Blog Post': 'content-type-blog',
                'Social Media': 'content-type-social', 
                'Location Page': 'content-type-location',
                'Email': 'content-type-email',
                'Video': 'content-type-video'
            };
            return typeMap[contentType] || 'content-type-blog';
        }

        // Helper function to truncate text
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }

        // Edit card content function
        function editCardContent(recordId) {
            const record = window.contentData.find(r => r.id === recordId);
            if (record) {
                showContentEditModal(record);
            }
        }

        // NEW: Content Preview Functions

        // Expand content preview in modal
        function expandContentPreview(recordId) {
            const record = window.contentData.find(r => r.id === recordId);
            if (record && record.textContent) {
                showContentPreviewModal(record);
            }
        }

        // Preview generated content (button action)
        function previewGeneratedContent(recordId) {
            const record = window.contentData.find(r => r.id === recordId);
            if (record && record.textContent) {
                showContentPreviewModal(record);
            }
        }

        // Show content preview modal
        function showContentPreviewModal(record) {
            const modal = document.createElement('div');
            modal.className = 'content-preview-modal';
            modal.innerHTML = `
                <div class="content-preview-modal-overlay" onclick="closeContentPreviewModal()"></div>
                <div class="content-preview-modal-content">
                    <div class="content-preview-modal-header">
                        <h3>📄 Generated Content Preview</h3>
                        <button onclick="closeContentPreviewModal()" class="modal-close-btn">×</button>
                    </div>
                    <div class="content-preview-modal-info">
                        <div class="preview-info-item">
                            <span class="info-label">Title:</span>
                            <span class="info-value">${record.description}</span>
                        </div>
                        <div class="preview-info-item">
                            <span class="info-label">Type:</span>
                            <span class="info-value">${record.contentType}</span>
                        </div>
                        <div class="preview-info-item">
                            <span class="info-label">Word Count:</span>
                            <span class="info-value">${record.wordCount || 0} words</span>
                        </div>
                        <div class="preview-info-item">
                            <span class="info-label">Content ID:</span>
                            <span class="info-value">${record.contentId}</span>
                        </div>
                    </div>
                    <div class="content-preview-modal-body">
                        <pre class="generated-content-text">${record.textContent}</pre>
                    </div>
                    <div class="content-preview-modal-actions">
                        <button onclick="copyContentToClipboard('${record.id}')" class="copy-content-btn">📋 Copy Content</button>
                        <button onclick="closeContentPreviewModal()" class="close-preview-btn">Close</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            document.body.style.overflow = 'hidden';
        }

        // Close content preview modal
        function closeContentPreviewModal() {
            const modal = document.querySelector('.content-preview-modal');
            if (modal) {
                document.body.removeChild(modal);
                document.body.style.overflow = 'auto';
            }
        }

        // Copy content to clipboard
        function copyContentToClipboard(recordId) {
            const record = window.contentData.find(r => r.id === recordId);
            if (record && record.textContent) {
                navigator.clipboard.writeText(record.textContent).then(() => {
                    // Show temporary success message
                    const btn = document.querySelector('.copy-content-btn');
                    const originalText = btn.textContent;
                    btn.textContent = '✅ Copied!';
                    btn.style.background = '#10b981';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy content:', err);
                    alert('Failed to copy content to clipboard');
                });
            }
        }

        // Initialize card draggable functionality
        function initializeCardDraggable() {
            console.log('🔄 Initializing card draggable functionality');
            // Cards already have draggable set up in createContentCard
        }

        // Update cards summary stats
        function updateCardsSummaryStats() {
            const localPlanningContent = window.contentData.filter(r => r.source !== 'airtable');
            
            const total = localPlanningContent.length;
            const selected = localPlanningContent.filter(r => r.selected).length;
            const highPriority = localPlanningContent.filter(r => r.priority === 'HIGH').length;
            
            // Update the commit button text and state
            const commitBtn = document.getElementById('commitBtn');
            const selectedCountText = document.getElementById('selectedCountText');
            
            if (selectedCountText) {
                selectedCountText.textContent = `${selected} records selected`;
            }
            
            if (commitBtn) {
                commitBtn.disabled = selected === 0;
                commitBtn.textContent = selected > 0 ? `📋 Commit ${selected} to Airtable` : '📋 Commit to Airtable';
            }
        }

        // Update commit button (renamed from updateSubmitButton)
        function updateCommitButton() {
            updateCardsSummaryStats();
        }

        // Rename setupInfrastructureForSelected to commitSelectedToAirtable 
        function commitSelectedToAirtable() {
            setupInfrastructureForSelected();
        }

        // Update field value
        function updateField(recordId, field, value) {
            const record = window.contentData.find(r => r.id === recordId);
            if (record) {
                const oldValue = record[field];
                record[field] = value;
                record.source = 'gui';
                
                // Mark as user-modified to prevent polling overwrites
                markUserModified(record, 'edit');
                
                // Update visual indicators immediately
                updateRowVisuals(recordId, field);
                
                // DEBUG: Log content type changes with more detail
                if (field === 'contentType') {
                    console.log('🔄 Content type changed:', {
                        recordId,
                        oldValue,
                        newValue: value,
                        recordInContentData: record
                    });
                }
                
                logStatus(`✏️ Updated ${field} for "${record.description}" (${field === 'contentType' ? `${oldValue} → ${value}` : value})`);
                updateSummaryStats();
            }
        }
        
        // Update row visual indicators after field changes
        function updateRowVisuals(recordId, changedField) {
            const row = document.querySelector(`tr[data-id="${recordId}"]`);
            if (!row) return;
            
            const record = window.contentData.find(r => r.id === recordId);
            if (!record) return;
            
            // Update content type class
            if (changedField === 'contentType') {
                // Remove old content type classes
                row.className = row.className.replace(/type-[a-z-]+/g, '');
                
                // Add new content type class
                const contentTypeClass = `type-${(record.contentType || 'Blog Post').toLowerCase().replace(/\s+/g, '-')}`;
                row.classList.add(contentTypeClass);
            }
            
            // Update user-modified class
            const isUserModified = record.userModified && isRecentlyUserModified(record);
            if (isUserModified) {
                row.classList.add('user-modified');
            } else {
                row.classList.remove('user-modified');
            }
            
            // Update status indicator in first column
            const statusIndicator = row.querySelector('.status-indicator');
            if (statusIndicator) {
                const isScheduled = record.scheduledDate || record.targetPublishDate;
                
                let statusIcon = isScheduled ? '📅' : '⋮⋮';
                let statusTitle = isScheduled ? `Scheduled: ${isScheduled}` : 'Drag to calendar to schedule';
                let statusColor = isScheduled ? 'var(--primary-green)' : '#666';
                
                // Show user modification indicator
                if (isUserModified) {
                    statusIcon = '✏️';
                    statusTitle = `Modified by user ${record.userAction || 'recently'} - protected from polling overwrites`;
                    statusColor = '#ff6b35';
                }
                
                statusIndicator.innerHTML = statusIcon;
                statusIndicator.title = statusTitle;
                statusIndicator.style.color = statusColor;
            }
        }

        // Toggle row selection
        function toggleRowSelection(recordId, selected) {
            const record = window.contentData.find(r => r.id === recordId);
            if (record) {
                record.selected = selected;
                record.modified_at = new Date().toISOString();
                
                // Update row appearance
                const row = document.querySelector(`tr[data-id="${recordId}"]`);
                if (row) {
                    if (selected) {
                        row.classList.add('selected');
                    } else {
                        row.classList.remove('selected');
                    }
                }
                
                updateSummaryStats();
                updateCommitButton();
                syncToClaude();
            }
        }

        // Bulk selection functions
        function selectAll() {
            window.contentData.forEach(record => {
                record.selected = true;
                record.modified_at = new Date().toISOString();
            });
            populateCards();
            logStatus('✅ Selected all records');
            syncToClaude();
        }

        function selectNone() {
            window.contentData.forEach(record => {
                record.selected = false;
                record.modified_at = new Date().toISOString();
            });
            populateCards();
            logStatus('❌ Deselected all records');
            syncToClaude();
        }

        function selectByPriority(priority) {
            window.contentData.forEach(record => {
                record.selected = record.priority === priority;
                record.modified_at = new Date().toISOString();
            });
            populateCards();
            logStatus(`🎯 Selected all ${priority} priority records`);
            syncToClaude();
        }

        // Row actions
        function duplicateRow(recordId) {
            const original = window.contentData.find(r => r.id === recordId);
            if (original) {
                const duplicate = {
                    ...original,
                    id: `temp_${Date.now()}_dup`,
                    description: original.description + ' (Copy)',
                    order: window.contentData.length,
                    created_at: new Date().toISOString(),
                    modified_at: new Date().toISOString()
                };
                
                window.contentData.push(duplicate);
                populateCards();
                logStatus(`📋 Duplicated: "${original.description}"`);
                syncToClaude();
            }
        }

        function deleteRow(recordId) {
            const index = window.contentData.findIndex(r => r.id === recordId);
            if (index !== -1) {
                const deleted = window.contentData.splice(index, 1)[0];
                
                // Reorder remaining items
                window.contentData.forEach((record, idx) => {
                    record.order = idx;
                });
                
                populateCards();
                
                // Refresh calendar if it exists
                if (calendar) {
                    // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                    updateCalendarStats();
                }
                logStatus(`🗑️ Deleted: "${deleted.description}"`);
                syncToClaude();
            }
        }

        // Toggle edit mode
        function toggleEditMode() {
            console.log('DEBUG: toggleEditMode() called, current editMode:', editMode);
            editMode = !editMode;
            console.log('DEBUG: toggleEditMode() new editMode:', editMode);
            const btn = document.getElementById('editModeBtn');
            
            if (editMode) {
                btn.textContent = '✏️ Edit Mode ON';
                btn.classList.add('active');
            } else {
                btn.textContent = '👁️ View Mode';
                btn.classList.remove('active');
            }
            
            console.log('DEBUG: About to call populateCards() after edit mode change. New editMode:', editMode);
            populateCards();
            console.log('DEBUG: Called populateCards() after edit mode change. Current editMode:', editMode);
            logStatus(`🔧 Switched to ${editMode ? 'Edit' : 'View'} mode`);
        }

        // HYBRID INFRASTRUCTURE SETUP
        
        // Generate content folder name with naming convention
        function generateContentFolderName(airtableId, description) {
            const slug = description
                .toLowerCase()
                .replace(/[^a-z0-9\s-]/g, '') // Remove special chars
                .replace(/\s+/g, '-')         // Spaces to hyphens
                .substring(0, 50);            // Limit length
            
            return `${airtableId}_${slug}`;
        }

        // Create Google Drive folder via N8N webhook
        async function createGoogleDriveFolder(folderName) {
            try {
                const webhookData = {
                    body: {
                        operation: "googledrive",
                        subOperation: 7, // Create folder operation
                        folderName: folderName,
                        parentId: "{{GOOGLE_DRIVE_FOLDER_ID}}" // Replace with actual parent folder ID
                    }
                };
                
                console.log('Creating Google Drive folder:', folderName);
                
                const response = await fetch('{{WEBHOOK_URL}}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(webhookData)
                });
                
                if (!response.ok) {
                    throw new Error(`Google Drive API failed: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('✅ Created Google Drive folder:', result);
                return result;
                
            } catch (error) {
                console.error('❌ Google Drive folder creation failed:', error);
                throw error;
            }
        }

        // Create content with full infrastructure setup
        async function createContentWithInfrastructure(contentData) {
            try {
                logStatus('🚀 Creating content infrastructure...');
                
                // Step 1: Create Airtable record first
                // Map content types to valid Airtable values
                let contentType = contentData.contentType || 'Blog Post';
                
                // Map dashboard values to Airtable field options
                // VERIFIED: These are the actual valid content type values in the Airtable base
                const contentTypeMapping = {
                    'Blog Post': 'Blog Post',             // ✅ Confirmed valid in Airtable data
                    'Social Media': 'Social Media',       // ✅ Confirmed valid in Airtable data
                    'Location Page': 'Location Page',     // ✅ Confirmed valid in Airtable data
                    'Location Service Page': 'Location Page'
                };
                
                contentType = contentTypeMapping[contentType] || 'Location Page';
                
                // Map pest types to valid Airtable values  
                let pestType = contentData.pestType || 'General';
                if (pestType === 'Spiders') {
                    pestType = 'General'; // Spiders not in schema, use General
                }
                
                // Read text content if available
                let textContent = contentData.textContent || '';
                if (!textContent && contentData.localContentFile) {
                    // Try to read from local file if path is provided
                    try {
                        // Extract relative path from absolute path for server access
                        const relativePath = contentData.localContentFile.includes('/content/') 
                            ? contentData.localContentFile.split('/content/')[1] 
                            : contentData.localContentFile;
                        const fileResponse = await fetch(`/content/${relativePath}`);
                        if (fileResponse.ok) {
                            textContent = await fileResponse.text();
                        }
                    } catch (err) {
                        console.log('Could not read local content file:', err);
                    }
                }
                
                // Join all keywords if array
                let allKeywords = '';
                if (contentData.keywords) {
                    if (Array.isArray(contentData.keywords)) {
                        allKeywords = contentData.keywords.join(', ');
                    } else {
                        allKeywords = contentData.keywords;
                    }
                }
                
                const airtableRecord = {
                    fields: {
                        "Title": contentData.title || '',
                        "Description": contentData.description || '',
                        "Content Type": contentType,
                        "Priority": contentData.priority || 'MEDIUM',
                        "Target Location": contentData.targetLocation || 'Multi-State',
                        "Pest Type": pestType,
                        "Primary Keyword": contentData.primaryKeyword || contentData.keywords || '',
                        "Content Format": "WordPress Blog",
                        "Seasonal Relevance": "Year-Round",
                        "Search Volume": parseInt(contentData.searchVolume) || 0,
                        "Keyword Difficulty": contentData.keywordDifficulty || 'Low',
                        "Publish Date": contentData.targetPublishDate || window.selectedContentDate || null,
                        "Text": textContent, // Include text content
                        "Notes": "AUTO_INITIALIZE_TRIGGER|" + (contentData.notes || "Created via Local Dashboard with Infrastructure Setup") + (allKeywords ? `\n\nKeywords: ${allKeywords}` : '')
                    }
                };
                
                console.log('Creating Airtable record with infrastructure setup:', airtableRecord);
                
                const airtableResponse = await fetch(`${AIRTABLE_CONFIG.apiUrl}/${AIRTABLE_CONFIG.baseId}/${AIRTABLE_CONFIG.tableId}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${AIRTABLE_CONFIG.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(airtableRecord)
                });
                
                if (!airtableResponse.ok) {
                    const errorBody = await airtableResponse.text();
                    console.error('Airtable error response:', errorBody);
                    console.error('Sent record data:', airtableRecord);
                    throw new Error(`Airtable record creation failed: ${airtableResponse.status} - ${errorBody}`);
                }
                
                const record = await airtableResponse.json();
                const recordId = record.id; // e.g., "rec123ABC"
                
                logStatus(`✅ Airtable record created: ${recordId}`);
                
                // Step 2: Create Google Drive folder with naming convention
                const folderName = generateContentFolderName(recordId, contentData.description);
                
                // Google Drive folder creation removed (outdated functionality)
                logStatus(`✅ Content infrastructure ready: ${recordId}`);
                return { recordId };
            } catch (error) {
                console.error('Error creating content infrastructure:', error);
                logStatus(`❌ Failed to create content infrastructure: ${error.message}`);
                throw error;
            }
        }

        // Submit selected records to Airtable
        async function submitSelectedToAirtable() {
            // Filter only unsubmitted selected records
            const selected = window.contentData.filter(r => r.selected && !r.submitted);
            
            if (selected.length === 0) {
                logStatus('❌ No records selected for submission');
                return;
            }
            
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = true;
            submitBtn.textContent = 'Submitting...';
            
            logStatus(`🚀 Submitting ${selected.length} records to Airtable...`);
            
            let successCount = 0;
            let errorCount = 0;
            
            for (const record of selected) {
                try {
                    // Read text content if available
                    let textContent = record.textContent || '';
                    if (!textContent && record.localFilePath) {
                        try {
                            // Try to read from local file if textContent not in memory
                            const response = await fetch(record.localFilePath);
                            if (response.ok) {
                                textContent = await response.text();
                            }
                        } catch (err) {
                            console.log('Could not read local file:', err);
                        }
                    }
                    
                    // Direct Airtable record creation - now includes Title and Text fields!
                    // Handle keywords - if it's an array, take the first one or join them
                    let primaryKeyword = record.primaryKeyword || '';
                    if (!primaryKeyword && record.keywords) {
                        if (Array.isArray(record.keywords)) {
                            primaryKeyword = record.keywords[0] || ''; // Take first keyword
                        } else {
                            primaryKeyword = record.keywords;
                        }
                    }
                    
                    const airtableRecord = {
                        fields: {
                            "Title": record.title || '', // ADDED: Title field
                            "Description": record.description || '',
                            "Content Type": record.contentType || '',
                            "Priority": record.priority || 'MEDIUM',
                            "Target Location": record.targetLocation || '',
                            "Pest Type": record.pestType || '',
                            "Content Format": record.contentFormat || 'WordPress Blog',
                            "Seasonal Relevance": record.seasonalRelevance || 'Year-Round',
                            "Primary Keyword": primaryKeyword, // Fixed: Handle array of keywords
                            "Search Volume": record.searchVolume || 0,
                            "Keyword Difficulty": record.keywordDifficulty || 'Low',
                            "Target Publish Date": record.targetPublishDate || '',
                            "Text": textContent, // ADDED: Text field with content
                            "Notes": `${record.notes || ''}${record.source === 'calendar' ? ' [Updated via Calendar]' : ''}${textContent ? `\nContent Length: ${textContent.length} characters` : ''}${Array.isArray(record.keywords) ? `\nAll Keywords: ${record.keywords.join(', ')}` : ''}`
                        }
                    };
                    
                    console.log('Creating Airtable record directly:', airtableRecord);
                    
                    const response = await fetch(`${AIRTABLE_CONFIG.apiUrl}/${AIRTABLE_CONFIG.baseId}/${AIRTABLE_CONFIG.tableId}`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${AIRTABLE_CONFIG.apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(airtableRecord)
                    });
                    
                    // Enhanced logging for direct API debugging
                    console.log('Airtable API response status:', response.status);
                    console.log('Airtable API response headers:', Object.fromEntries(response.headers));
                    
                    if (response.ok) {
                        const responseData = await response.json();
                        console.log('✅ Created Airtable record:', responseData);
                        logStatus(`✅ Created in Airtable: ${record.description}`);
                        successCount++;
                        
                        // Mark as submitted and store Airtable ID
                        record.submitted = true;
                        record.submitted_at = new Date().toISOString();
                        record.airtableId = responseData.id; // Store the new record ID
                        
                        // ENHANCED: Record cleanup after successful submission
                        try {
                            // Add visual success indicator with animation
                            const cardElement = document.querySelector(`[data-id="${record.id}"]`);
                            if (cardElement) {
                                cardElement.style.transition = 'all 0.3s ease-in-out';
                                cardElement.style.transform = 'scale(0.95)';
                                cardElement.style.backgroundColor = '#dcfce7'; // Light green
                                cardElement.style.borderColor = '#16a34a'; // Green border
                                
                                // Add success checkmark overlay
                                const successOverlay = document.createElement('div');
                                successOverlay.innerHTML = `
                                    <div style="position: absolute; top: 10px; right: 10px; background: #16a34a; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; z-index: 10; animation: fadeIn 0.3s ease-in-out;">
                                        ✓
                                    </div>
                                `;
                                successOverlay.style.position = 'relative';
                                cardElement.appendChild(successOverlay);
                                
                                // Fade out after 2 seconds
                                setTimeout(() => {
                                    cardElement.style.opacity = '0';
                                    cardElement.style.transform = 'scale(0.8)';
                                    
                                    setTimeout(() => {
                                        // Remove from UI after fade animation
                                        if (cardElement.parentNode) {
                                            cardElement.parentNode.removeChild(cardElement);
                                        }
                                    }, 300);
                                }, 2000);
                            }
                            
                            // Remove from contentData array after visual feedback
                            setTimeout(() => {
                                const recordIndex = window.contentData.findIndex(r => r.id === record.id);
                                if (recordIndex !== -1) {
                                    window.contentData.splice(recordIndex, 1);
                                    console.log(`🧹 Removed submitted record ${record.id} from staging area`);
                                    
                                    // Call API to remove from planning state
                                    fetch('http://localhost:3002/api/planning-state/remove-record', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json'
                                        },
                                        body: JSON.stringify({ recordId: record.id })
                                    }).then(response => {
                                        if (response.ok) {
                                            console.log(`🧹 Removed record ${record.id} from planning state`);
                                        } else {
                                            console.warn(`⚠️ Could not remove record ${record.id} from planning state`);
                                        }
                                    }).catch(err => {
                                        console.warn('⚠️ Planning state cleanup failed:', err);
                                    });
                                    
                                    // Update UI counters and summary
                                    updateSummaryStats();
                                    updateCommitButton();
                                }
                            }, 2300); // Slightly after fade out completes
                            
                        } catch (cleanupError) {
                            console.warn('⚠️ Record cleanup animation failed:', cleanupError);
                        }
                    } else {
                        const errorText = await response.text();
                        console.error('❌ Airtable API error:', errorText);
                        logStatus(`❌ Failed: ${record.description} (${response.status}: ${errorText})`);
                        errorCount++;
                    }
                    
                    // Rate limiting delay
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                } catch (error) {
                    logStatus(`❌ Error submitting ${record.description}: ${error.message}`);
                    errorCount++;
                }
            }
            
            submitBtn.disabled = false;
            submitBtn.textContent = 'Submit Selected Records';
            
            logStatus(`🎉 Submission completed! Success: ${successCount}, Errors: ${errorCount}`);
            
            if (successCount > 0) {
                logStatus(`📊 ${successCount} records are now in Airtable and ready for N8N workflows`);
                // Refresh UI to show submitted status
                populateCards();
                updateSummaryStats();
                updateCommitButton();
            }
            
            syncToClaude();
        }

        // Set up infrastructure for selected local content
        async function setupInfrastructureForSelected() {
            const selected = window.contentData.filter(r => r.selected && !r.airtableId && r.source !== 'airtable');
            
            if (selected.length === 0) {
                logStatus('❌ No local records selected for infrastructure setup');
                return;
            }
            
            const setupBtn = document.getElementById('setupInfraBtn');
            if (setupBtn) {
                setupBtn.disabled = true;
                setupBtn.textContent = 'Setting up...';
            }
            
            logStatus(`🏗️ Setting up infrastructure for ${selected.length} local records...`);
            
            let successCount = 0;
            let errorCount = 0;
            
            for (const record of selected) {
                try {
                    // Handle keywords - extract first keyword for Primary Keyword field
                    let primaryKeyword = '';
                    if (record.keywords) {
                        if (Array.isArray(record.keywords)) {
                            primaryKeyword = record.keywords[0] || '';
                        } else {
                            primaryKeyword = record.keywords;
                        }
                    } else if (record.primaryKeyword) {
                        primaryKeyword = record.primaryKeyword;
                    }
                    
                    const contentData = {
                        title: record.title || '',
                        description: record.description,
                        contentType: record.contentType,
                        priority: record.priority,
                        productionMethod: record.productionMethod || 'Local',
                        keywords: record.keywords, // Pass the full array for the Keywords field
                        primaryKeyword: primaryKeyword, // Pass single string for Primary Keyword field
                        targetPublishDate: record.targetPublishDate,
                        textContent: record.textContent || '',
                        localContentFile: record.localContentFile || record.localFilePath,
                        notes: record.notes || ''
                    };
                    
                    const infrastructure = await createContentWithInfrastructure(contentData);
                    
                    // Update the existing record with infrastructure data
                    record.airtableId = infrastructure.recordId;
                    record.folderId = infrastructure.folderId;
                    record.folderLink = infrastructure.folderLink;
                    record.folderName = infrastructure.folderName;
                    record.infrastructureReady = true;
                    record.source = 'local-with-infrastructure';
                    record.modified_at = new Date().toISOString();
                    
                    logStatus(`✅ Infrastructure ready: ${infrastructure.folderName}`);
                    successCount++;
                    
                    // Rate limiting delay
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                } catch (error) {
                    logStatus(`❌ Infrastructure setup failed for ${record.description}: ${error.message}`);
                    errorCount++;
                }
            }
            
            if (setupBtn) {
                setupBtn.disabled = false;
                setupBtn.textContent = '🏗️ Setup Infrastructure';
            }
            
            // Refresh display
            populateCards();
            if (false) { // Calendar disabled
                try {
                    // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                    updateCalendarStats();
                } catch (error) {
                    console.error('Error refreshing calendar:', error);
                }
            }
            
            logStatus(`🎉 Infrastructure setup completed! Success: ${successCount}, Errors: ${errorCount}`);
            syncToClaude();
        }

        // Export to CSV
        function exportToCSV() {
            if (window.contentData.length === 0) {
                logStatus('❌ No content to export');
                return;
            }
            
            const headers = [
                'Content ID', 'Description', 'Target Publish Date', 'Status', 'Content Type',
                'Priority', 'Target Location', 'Pest Type', 'Primary Keyword',
                'Content Format', 'Seasonal Relevance', 'Search Volume', 'Keyword Difficulty', 'Notes'
            ];
            
            let csv = headers.join(',') + '\n';
            
            window.contentData.forEach(record => {
                const row = [
                    '', // Content ID (Airtable assigns)
                    record.description || '',
                    record.targetPublishDate || '', // Target Publish Date
                    '', // Status
                    record.contentType || '',
                    record.priority || '',
                    record.targetLocation || '',
                    record.pestType || '',
                    record.primaryKeyword || '',
                    record.contentFormat || '',
                    record.seasonalRelevance || '',
                    record.searchVolume || '',
                    record.keywordDifficulty || '',
                    record.notes || ''
                ].map(field => `"${String(field).replace(/"/g, '""')}"`);
                
                csv += row.join(',') + '\n';
            });
            
            // Download CSV file
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `client_content_plan_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
            
            logStatus(`📄 Exported ${window.contentData.length} records to CSV`);
        }

        // Clear all records - ENHANCED to prevent restore persistence issues and fix count discrepancy
        async function clearAllRecords() {
            // First, get the current API state to show accurate count in confirmation
            let actualRecordCount = 0;
            try {
                const response = await fetch('http://localhost:3002/api/planning-state', {
                    headers: { 'Cache-Control': 'no-cache' }
                });
                if (response.ok) {
                    const data = await response.json();
                    actualRecordCount = data.content_records ? data.content_records.length : 0;
                }
            } catch (error) {
                // Fallback to window.contentData if API is unavailable
                actualRecordCount = window.contentData ? window.contentData.length : 0;
            }
            
            if (actualRecordCount === 0) {
                // Even if visually empty, force clear any hidden/cached data
                localStorage.removeItem('client_planning_state');
                try {
                    await fetch('http://localhost:3002/api/planning-state', { method: 'DELETE' });
                    logStatus('✅ Forced cleanup of any residual data');
                } catch (error) {
                    console.log('Cleanup attempt completed');
                }
                return;
            }
            
            if (confirm(`Are you sure you want to clear all ${actualRecordCount} records?`)) {
                // Clear local data completely
                window.contentData = [];
                window.airtableData = [];
                
                // Clear ALL localStorage items related to planning
                localStorage.removeItem('client_planning_state');
                localStorage.removeItem('client_content_data');
                localStorage.removeItem('client_airtable_data');
                logStatus('🧹 Cleared all localStorage caches');
                
                // Clear the sync bridge state with archival
                try {
                    const response = await fetch('http://localhost:3002/api/planning-state', {
                        method: 'DELETE',
                        headers: { 'Cache-Control': 'no-cache' }
                    });
                    
                    if (response.ok) {
                        logStatus('📦 Records archived and cleared from sync system');
                        logStatus('💾 Records preserved in /archive/planning-sessions/ for recovery');
                        
                        // Force complete UI refresh after successful clear
                        setTimeout(() => {
                            populateCards();
                            updateSummaryStats();
                            updateCommitButton();
                            if (window.fullCalendarInstance) {
                                updateCalendarStats();
                            }
                            logStatus('✅ Complete clear successful - UI refreshed');
                        }, 100);
                    } else {
                        logStatus('⚠️ Server clear may have failed, forcing local cleanup');
                        populateCards();
                        updateSummaryStats();
                        updateCommitButton();
                    }
                } catch (error) {
                    logStatus('⚠️ Server unavailable, completed local clear');
                    populateCards();
                    updateSummaryStats();
                    updateCommitButton();
                }
                
                // Don't call syncToClaude() after clearing - it would save empty data to localStorage
                const lastUpdatedEl = document.getElementById('lastUpdated');
                if (lastUpdatedEl) {
                    lastUpdatedEl.textContent = new Date().toLocaleTimeString();
                }
            }
        }

        // Load from Claude Code sync system - FIXED for proper archive restoration
        async function loadFromClaude(forceReplace = false) {
            logStatus('🔄 Loading content from Claude Code sync...');
            
            try {
                // Try to load from API endpoint first with no-cache headers
                const response = await fetch('http://localhost:3002/api/planning-state', {
                    headers: { 'Cache-Control': 'no-cache, no-store, must-revalidate' }
                });
                
                if (response.ok) {
                    const state = await response.json();
                    console.log('📊 API Response:', state);
                    console.log('📊 Records found:', state.content_records ? state.content_records.length : 0);
                    
                    if (state.content_records && state.content_records.length > 0) {
                        // Check if this is a restore operation (records have restoredFrom field)
                        const isRestoreOperation = state.content_records.some(r => r.restoredFrom);
                        
                        if (forceReplace || isRestoreOperation) {
                            // For restore operations, completely replace the content
                            window.contentData = state.content_records;
                            logStatus(`🔄 Restored ${window.contentData.length} records from archive`);
                        } else {
                            // Smart merge: preserve user-modified records while updating from sync
                            const incomingRecords = state.content_records;
                            const existingRecords = window.contentData || [];
                            
                            // Merge each incoming record with existing data (preserving user changes)
                            const mergedRecords = incomingRecords.map(incomingRecord => {
                                const existingRecord = existingRecords.find(e => e.id === incomingRecord.id);
                                return smartMergeRecord(existingRecord, incomingRecord);
                            });
                            
                            // Add any existing records that weren't in the incoming set (user-created content)
                            const existingUserRecords = existingRecords.filter(existing => 
                                !incomingRecords.find(incoming => incoming.id === existing.id)
                            );
                            
                            window.contentData = [...mergedRecords, ...existingUserRecords];
                        }
                        
                        populateCards();
                        updateSummaryStats();
                        updateCommitButton();
                        
                        logStatus(`✅ Loaded ${window.contentData.length} records from Claude Code sync`);
                        logStatus(`📊 Session: ${state.planning_session_id}`);
                        
                        // Update session ID in UI
                        document.getElementById('sessionId').textContent = state.planning_session_id;
                        
                        return;
                    } else {
                        logStatus('📝 No content found in Claude Code sync');
                    }
                } else {
                    logStatus('⚠️ API not available, trying direct file access...');
                }
                
            } catch (error) {
                logStatus(`⚠️ API error: ${error.message}`);
            }
            
            // Ready for content planning - no fallback demo content
            logStatus('📝 No existing content found - ready for new planning');
            populateCards();
            updateSummaryStats();
            updateCommitButton();
        }
        
        // Add debugging function to check dashboard state
        function debugDashboardState() {
            console.log('=== DASHBOARD DEBUG STATE ===');
            console.log('window.contentData:', window.contentData?.length || 0, 'items');
            console.log('cardsContainer exists:', !!document.getElementById('cardsContainer'));
            console.log('cardsEmptyState exists:', !!document.getElementById('cardsEmptyState'));
            console.log('calendar disabled (staging dashboard)');
            console.log('sessionId:', document.getElementById('sessionId')?.textContent);
            console.log('=== END DEBUG STATE ===');
            
            // Also log to status for user visibility
            const cardsContainer = document.getElementById('cardsContainer');
            const emptyState = document.getElementById('cardsEmptyState');
            logStatus(`🔍 Debug: ${window.contentData?.length || 0} items, DOM: ${!!cardsContainer}/${!!emptyState}, Calendar: disabled`);
        }
        
        // Make debug function available globally
        window.debugDashboardState = debugDashboardState;
        
        // Test function for collapsible sections
        window.testToggle = function(sectionId) {
            console.log('🧪 Testing toggle for:', sectionId);
            toggleSection(sectionId);
        };
        
        // Make toggleSection globally available
        window.toggleSection = toggleSection;
        
        // Simple test function to load data manually
        window.testLoadData = async function() {
            console.log('🧪 Testing data load...');
            try {
                await loadFromClaude();
                console.log('✅ Data load successful');
                console.log('📊 Current data:', window.contentData);
            } catch (error) {
                console.error('❌ Data load failed:', error);
            }
        };

        // Global auto-sync state
        let autoSyncPaused = false;
        let autoSyncIntervals = [];
        
        // Toggle auto-sync pause/resume
        function toggleAutoSync() {
            autoSyncPaused = !autoSyncPaused;
            const btn = document.getElementById('pauseSyncBtn');
            
            if (autoSyncPaused) {
                btn.innerHTML = '▶️ Resume Auto-Sync';
                btn.style.background = '#dc3545'; // Red color
                logStatus('⏸️ Auto-sync paused - user changes are protected');
            } else {
                btn.innerHTML = '⏸️ Pause Auto-Sync';
                btn.style.background = '#28a745'; // Green color
                logStatus('▶️ Auto-sync resumed - polling will continue');
            }
        }
        
        // DISABLED: Automatic Airtable polling (was consuming excessive N8N executions)
        function startAutomaticPolling() {
            console.log('🚫 Automatic Airtable polling DISABLED to prevent excessive N8N executions');
            logStatus('🚫 Automatic polling DISABLED - use "🔄 Refresh Calendar Data" button for updates');
            // Commented out to prevent N8N execution consumption
            /*
            // Poll every 30 seconds for calendar updates
            const airtableInterval = setInterval(async () => {
                if (autoSyncPaused) {
                    console.log('🚫 Auto-sync paused - skipping Airtable poll');
                    return;
                }
                
                try {
                    await pollAirtable();
                    if (calendar) {
                        // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                        updateCalendarStats();
                    }
                } catch (error) {
                    console.error('Automatic polling error:', error);
                }
            }, 30000);
            
            autoSyncIntervals.push(airtableInterval);
            logStatus('🔄 Started automatic Airtable polling (30s intervals)');
            */
        }

        // Manual Airtable polling
        async function manualPollAirtable() {
            const button = document.querySelector('[onclick="manualPollAirtable()"]');
            if (button) {
                button.disabled = true;
                button.textContent = '🔄 Refreshing...';
            }
            
            // Ensure window.contentData exists
            if (!window.contentData) {
                window.contentData = [];
            }
            
            logStatus('🔄 Manually refreshing Airtable data...');
            await pollAirtable();
            
            // Force calendar refresh if it exists (regardless of visibility)
            if (calendar) {
                setTimeout(() => {
                    // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                    calendar.render();
                    updateCalendarStats();
                    logStatus('📅 Calendar events refreshed');
                }, 200);
            }
            
            if (button) {
                button.disabled = false;
                button.textContent = '🔄 Refresh Calendar Data';
            }
        }
        
        async function pollAirtable() {
            try {
                logStatus('🔄 Loading Airtable data directly...');
                
                // Direct Airtable API call - no more N8N webhook!
                const response = await fetch(`${AIRTABLE_CONFIG.apiUrl}/${AIRTABLE_CONFIG.baseId}/${AIRTABLE_CONFIG.tableId}`, {
                    headers: {
                        'Authorization': `Bearer ${AIRTABLE_CONFIG.apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    logStatus(`❌ Airtable API failed: ${response.status} ${response.statusText}`);
                    console.error('Airtable API Error:', {
                        status: response.status,
                        statusText: response.statusText,
                        url: response.url
                    });
                    return;
                }
                
                const data = await response.json();
                console.log('✅ Direct Airtable API response:', data);
                
                if (data && data.records) {
                    const records = data.records;
                    logStatus(`📊 Loaded ${records.length} records from Airtable directly`);
                    
                    // Process Airtable records (fields are nested under .fields property)
                    const airtableEvents = records.map(record => ({
                        id: `airtable_${record.id}`,
                        description: record.fields.Description || record.fields.Title || 'Untitled',
                        targetPublishDate: record.fields['Publish Date'] || record.fields['Target Date'],
                        contentType: record.fields['Content Type'] || 'Blog Post',
                        priority: record.fields.Priority || 'MEDIUM',
                        targetLocation: record.fields['Target Location'] || record.fields.Location || 'Multi-State',
                        pestType: record.fields['Pest Type'] || record.fields['Pest Focus'] || 'General',
                        primaryKeyword: record.fields['Primary Keyword'] || record.fields.Keywords || record.fields['SEO Keywords'] || '',
                        notes: record.fields.Notes || record.fields['Brad Notes'] || '',
                        generationType: 'SYSTEMATIC',
                        source: 'airtable',
                        status: record.fields.Status || 'Planned',
                        selected: false, // Airtable items are read-only in local view
                        airtableId: record.id // Store original Airtable ID
                    }));
                    
                    // Smart merge: preserve user-modified records while updating Airtable data
                    const existingNonAirtable = window.contentData.filter(item => item.source !== 'airtable');
                    const existingAirtable = window.contentData.filter(item => item.source === 'airtable');
                    
                    // Merge each Airtable event with existing data (preserving user changes)
                    const mergedAirtableEvents = airtableEvents.map(incomingEvent => {
                        const existingEvent = existingAirtable.find(e => e.id === incomingEvent.id);
                        return smartMergeRecord(existingEvent, incomingEvent);
                    });
                    
                    window.contentData = [...existingNonAirtable, ...mergedAirtableEvents];
                    
                    // Update calendar - always visible in unified layout
                    if (false) { // Calendar disabled
                        // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                        updateCalendarStats();
                    }
                    
                    logStatus(`✅ Loaded ${records.length} records directly from Airtable (No N8N cost!)`);
                } else {
                    logStatus('⚠️ No Airtable records found or unexpected API response');
                    console.log('Airtable API response:', data);
                }
            } catch (error) {
                logStatus(`❌ Airtable API error: ${error.message}`);
                console.error('Direct Airtable API error:', error);
            }
        }
        
        // Create local MD file for LOCAL content
        async function createLocalFile(recordId) {
            try {
                const response = await fetch('/api/create-local-file', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ recordId })
                });
                
                if (!response.ok) throw new Error('Failed to create local file');
                
                const data = await response.json();
                if (data.success) {
                    logStatus(`📝 Created local file: ${data.filePath}`);
                    
                    // Update record status
                    const record = window.contentData.find(r => r.id === recordId);
                    if (record) {
                        record.localFilePath = data.filePath;
                        record.status = 'draft';
                        populateCards();
                        syncToClaude();
                    }
                }
            } catch (error) {
                logStatus(`❌ Error creating local file: ${error.message}`);
            }
        }
        
        // === USER CHANGE TRACKING SYSTEM ===
        
        // Mark a record as user-modified to prevent polling overwrites
        function markUserModified(record, action = 'edit') {
            if (!record) return;
            
            const now = new Date().toISOString();
            record.userModified = true;
            record.lastUserModified = now;
            record.userAction = action; // 'edit', 'drag', 'schedule', etc.
            record.modified_at = now;
            
            // Mark as locally modified for visual indication
            record.locallyModified = true;
            
            console.log(`🔄 User modified record: ${record.id} (${action})`);
            
            // Auto-save after user modification
            setTimeout(() => {
                syncToClaude();
            }, 500);
        }
        
        // Check if a record has been user-modified recently (within last 5 minutes)
        function isRecentlyUserModified(record, thresholdMinutes = 5) {
            if (!record || !record.userModified || !record.lastUserModified) {
                return false;
            }
            
            const lastModified = new Date(record.lastUserModified);
            const now = new Date();
            const diffMinutes = (now - lastModified) / (1000 * 60);
            
            return diffMinutes <= thresholdMinutes;
        }
        
        // Smart merge: preserve user changes while updating system fields
        function smartMergeRecord(existingRecord, incomingRecord) {
            if (!existingRecord) return incomingRecord;
            
            // If user has made recent changes, preserve them
            if (isRecentlyUserModified(existingRecord)) {
                console.log(`⚠️ Preserving user changes for record: ${existingRecord.id}`);
                
                // Keep user-modified fields, but allow system updates for safe fields
                const merged = { ...incomingRecord };
                
                // Preserve user-modifiable fields
                if (existingRecord.userModified) {
                    merged.scheduledDate = existingRecord.scheduledDate;
                    merged.targetPublishDate = existingRecord.targetPublishDate;
                    merged.selected = existingRecord.selected;
                    merged.priority = existingRecord.priority;
                    merged.status = existingRecord.status;
                    merged.contentType = existingRecord.contentType;
                    
                    // Preserve user tracking metadata
                    merged.userModified = existingRecord.userModified;
                    merged.lastUserModified = existingRecord.lastUserModified;
                    merged.userAction = existingRecord.userAction;
                    merged.locallyModified = existingRecord.locallyModified;
                }
                
                return merged;
            }
            
            // No recent user changes, safe to use incoming record
            return incomingRecord;
        }
        
        // Clear user modification flags (call when user explicitly accepts remote changes)
        function clearUserModifications(record) {
            if (!record) return;
            
            delete record.userModified;
            delete record.lastUserModified;
            delete record.userAction;
            delete record.locallyModified;
            
            console.log(`✅ Cleared user modification flags for: ${record.id}`);
        }
        
        function syncToClaude() {
            // Save to localStorage for persistence
            const state = {
                session_id: sessionId,
                content_records: contentData,
                last_updated: new Date().toISOString()
            };
            
            localStorage.setItem('client_planning_state', JSON.stringify(state));
            
            // Also save to sync bridge for persistence across sessions
            saveToBridge(state);
            
            // Update the UI
            const lastUpdatedEl = document.getElementById('lastUpdated');
            if (lastUpdatedEl) {
                lastUpdatedEl.textContent = new Date().toLocaleTimeString();
            }
        }
        
        // Save state to sync bridge (async, non-blocking)
        async function saveToBridge(state) {
            try {
                const response = await fetch('http://localhost:3002/api/planning-state', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(state)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log(`🔄 Sync bridge updated: ${result.recordCount} records`);
                } else {
                    console.warn('⚠️ Sync bridge save failed, using localStorage only');
                }
            } catch (error) {
                console.warn('⚠️ Sync bridge not available, using localStorage only:', error.message);
            }
        }

        // Update summary statistics (Card View - LOCAL planning content only)
        function updateSummaryStats() {
            // Only count LOCAL planning content (exclude Airtable tracking items)
            const localPlanningContent = window.contentData.filter(r => r.source !== 'airtable');
            
            const total = localPlanningContent.length;
            const selected = localPlanningContent.filter(r => r.selected).length;
            const highPriority = localPlanningContent.filter(r => r.priority === 'HIGH').length;
            
            // These elements were removed in the redesign - use card-based stats instead
            console.log(`📊 Planning Stats: ${total} total, ${selected} selected, ${highPriority} high priority`);
            
            // Update the card-based stats
            updateCardsSummaryStats();
        }

        // Update submit button state
        function updateCommitButton() {
            // Count different types of selected content
            const selectedForSubmit = window.contentData ? window.contentData.filter(r => r.selected && r.source !== 'airtable').length : 0;
            const selectedForInfrastructure = window.contentData ? window.contentData.filter(r => r.selected && !r.airtableId && r.source !== 'airtable').length : 0;
            
            const submitBtn = document.getElementById('commitBtn'); // Fixed: was submitBtn, now commitBtn
            const infrastructureBtn = document.getElementById('setupInfraBtn');
            
            // Update submit button
            if (submitBtn) {
                submitBtn.disabled = selectedForSubmit === 0;
                if (selectedForSubmit === 0) {
                    submitBtn.textContent = '📋 Commit to Airtable';
                } else {
                    submitBtn.textContent = `📋 Commit ${selectedForSubmit} to Airtable`;
                }
            }
            
            // Update infrastructure button
            if (infrastructureBtn) {
                infrastructureBtn.disabled = selectedForInfrastructure === 0;
                if (selectedForInfrastructure === 0) {
                    infrastructureBtn.textContent = '🏗️ No Local Content Selected';
                } else {
                    infrastructureBtn.textContent = `🏗️ Setup Infrastructure (${selectedForInfrastructure})`;
                }
            }
        }

        // Update empty state visibility
        function updateEmptyState() {
            const emptyState = document.getElementById('cardsEmptyState');
            const cardsContainer = document.getElementById('cardsContainer');
            
            // Validate DOM elements exist
            if (!cardsContainer) {
                console.warn('updateEmptyState: cardsContainer not found');
                return;
            }
            
            // Always show the cards container
            cardsContainer.style.display = 'block';
            
            // Show/hide empty state based on content
            if (emptyState) {
                if (!window.contentData || window.contentData.length === 0) {
                    emptyState.style.display = 'block';
                } else {
                    emptyState.style.display = 'none';
                }
            }
        }

        // Log status messages
        function logStatus(message) {
            const statusLog = document.getElementById('statusLog');
            const timestamp = new Date().toLocaleTimeString();
            statusLog.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            statusLog.scrollTop = statusLog.scrollHeight;
            
            console.log(`[{{CLIENT_NAME}} Dashboard] ${message}`);
        }

        // Copy status log to clipboard
        function copyStatusLog() {
            const statusLog = document.getElementById('statusLog');
            const logText = statusLog.innerText;
            
            navigator.clipboard.writeText(logText).then(() => {
                logStatus('📋 Status log copied to clipboard');
            }).catch(err => {
                logStatus('❌ Failed to copy status log: ' + err.message);
            });
        }

        // Refresh Airtable data manually
        function refreshAirtableData() {
            logStatus('🔄 Manually refreshing Airtable data...');
            pollAirtable();
        }
        
        // Create a visual drag image for cards
        function createDragImage(record) {
            const dragImage = document.createElement('div');
            dragImage.style.cssText = `
                position: absolute;
                top: -1000px;
                left: -1000px;
                width: 250px;
                padding: 12px 16px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border-radius: 8px;
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 14px;
                font-weight: 600;
                z-index: 10000;
                pointer-events: none;
            `;
            
            const contentType = record.contentType || 'Blog Post';
            const priority = record.priority || 'MEDIUM';
            const description = record.description || 'Content Item';
            
            dragImage.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 12px; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">${contentType}</span>
                    <span style="background: rgba(255,255,255,0.3); padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 700;">${priority}</span>
                </div>
                <div style="font-weight: 500; line-height: 1.3; opacity: 0.95;">
                    ${description.length > 60 ? description.substring(0, 60) + '...' : description}
                </div>
            `;
            
            document.body.appendChild(dragImage);
            
            // Remove after a short delay to clean up
            setTimeout(() => {
                if (dragImage.parentNode) {
                    dragImage.parentNode.removeChild(dragImage);
                }
            }, 1000);
            
            return dragImage;
        }

        // Setup native HTML5 drop zone for calendar
        function setupCalendarDropZone() {
            const calendarEl = document.getElementById('calendar');
            if (!calendarEl) {
                console.log('Calendar element not found for drop zone setup');
                return;
            }
            
            console.log('Setting up calendar drop zone...');
            
            // Allow drop events
            calendarEl.addEventListener('dragover', function(e) {
                e.preventDefault(); // Allow drop
                e.dataTransfer.dropEffect = 'move';
            });
            
            calendarEl.addEventListener('dragenter', function(e) {
                e.preventDefault(); // Allow drop
            });
            
            calendarEl.addEventListener('drop', function(e) {
                e.preventDefault();
                console.log('Native HTML5 drop event triggered');
                
                try {
                    const data = e.dataTransfer.getData('text/plain');
                    if (data) {
                        const cachedRecord = JSON.parse(data);
                        const recordId = cachedRecord.id;
                        console.log('Dropped record ID:', recordId);
                        
                        // Get the date from the drop target
                        const dateCell = e.target.closest('[data-date]');
                        if (dateCell) {
                            const dateStr = dateCell.getAttribute('data-date');
                            console.log('Drop date:', dateStr);
                            
                            // CRITICAL FIX: Always use current record data from contentData, not cached data
                            const existingRecord = window.contentData.find(r => r.id === recordId);
                            if (existingRecord) {
                                existingRecord.targetPublishDate = dateStr;
                                existingRecord.scheduledDate = dateStr;
                                
                                // Mark as user-modified to prevent polling overwrites
                                markUserModified(existingRecord, 'drag');
                                
                                logStatus(`📅 Scheduled: "${existingRecord.description.substring(0, 50)}..." on ${dateStr} (${existingRecord.contentType})`);
                                
                                // Refresh calendar and table
                                if (false) { // Calendar disabled
                                    // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                                }
                                populateCards();
                                updateCalendarStats();
                            }
                        } else {
                            // Try to get date from calendar's current view
                            const currentDate = new Date().toISOString().split('T')[0];
                            console.log('Using current date as fallback:', currentDate);
                            
                            const existingRecord = window.contentData.find(r => r.id === record.id);
                            if (existingRecord) {
                                existingRecord.targetPublishDate = currentDate;
                                existingRecord.scheduledDate = currentDate;
                                existingRecord.modified_at = new Date().toISOString();
                                
                                logStatus(`📅 Scheduled: "${record.description.substring(0, 50)}..." on ${currentDate}`);
                                
                                // Refresh calendar and table
                                if (false) { // Calendar disabled
                                    // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
                                }
                                populateCards();
                                updateCalendarStats();
                                syncToClaude();
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error processing native drop:', error);
                    logStatus(`❌ Drop failed: ${error.message}`);
                }
            });
            
            logStatus('📋 Native HTML5 drop zone added to calendar');
        }

        // Initialize FullCalendar external draggable elements
        function initializeExternalDraggable() {
            // Try multiple selectors to find the table
            const tableElement = document.querySelector('.content-table') || 
                                document.querySelector('table') || 
                                document.getElementById('contentTable');
            
            // Extensive debug logging
            console.log('Initializing draggable...', {
                tableElement: !!tableElement,
                tableSelector: '.content-table',
                allTables: document.querySelectorAll('table').length,
                contentTableExists: !!document.querySelector('.content-table'),
                tableStyle: tableElement ? getComputedStyle(tableElement).display : 'not found',
                FullCalendar: typeof FullCalendar,
                Draggable: typeof FullCalendar?.Draggable,
                InteractionDraggable: typeof FullCalendar?.Interaction?.Draggable,
                draggableItems: document.querySelectorAll('.draggable-planning-item').length
            });
            
            // Log all available table elements for debugging
            const allTables = document.querySelectorAll('table');
            allTables.forEach((table, index) => {
                console.log(`Table ${index}:`, {
                    className: table.className,
                    id: table.id,
                    tagName: table.tagName,
                    display: getComputedStyle(table).display
                });
            });
            
            if (tableElement && typeof FullCalendar !== 'undefined' && (FullCalendar.Draggable || FullCalendar.Interaction?.Draggable)) {
                // Clean up any existing draggable instance
                if (window.fcDraggable) {
                    window.fcDraggable.destroy();
                }
                
                try {
                    // Initialize FullCalendar Draggable for table rows
                    const DraggableClass = FullCalendar.Draggable || FullCalendar.Interaction?.Draggable;
                    window.fcDraggable = new DraggableClass(tableElement, {
                        itemSelector: '.draggable-planning-item',
                        eventData: function(eventEl) {
                            console.log('EventData called for:', eventEl);
                            const recordData = eventEl.dataset.recordData;
                            if (recordData) {
                                try {
                                    const cachedRecord = JSON.parse(recordData);
                                    
                                    // CRITICAL FIX: Use current record data from contentData, not cached data
                                    const currentRecord = window.contentData.find(r => r.id === cachedRecord.id);
                                    const record = currentRecord || cachedRecord; // Fallback to cached if not found
                                    
                                    const eventData = {
                                        title: record.description.substring(0, 50) + '...',
                                        id: record.id,
                                        extendedProps: record
                                    };
                                    console.log('Returning event data with current content type:', eventData, `(${record.contentType})`);
                                    return eventData;
                                } catch (error) {
                                    console.error('Error parsing record data:', error);
                                    return null;
                                }
                            }
                            return null;
                        }
                    });
                    
                    logStatus(`🔧 External drag-and-drop initialized for ${document.querySelectorAll('.draggable-planning-item').length} items`);
                    console.log('FullCalendar Draggable initialized successfully');
                } catch (error) {
                    logStatus(`❌ Failed to initialize draggable: ${error.message}`);
                    console.error('Draggable initialization error:', error);
                }
            } else {
                logStatus('⚠️ FullCalendar Draggable not available');
                console.log('Missing dependencies:', {
                    tableElement: !!tableElement,
                    FullCalendar: typeof FullCalendar,
                    Draggable: typeof FullCalendar?.Draggable
                });
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey || event.metaKey) {
                switch (event.key) {
                    case 'a':
                        event.preventDefault();
                        selectAll();
                        break;
                    case 'd':
                        event.preventDefault();
                        selectNone();
                        break;
                    case 's':
                        event.preventDefault();
                        exportToCSV();
                        break;
                    case 'Enter':
                        event.preventDefault();
                        submitSelectedToAirtable();
                        break;
                }
            }
        });

        // Tab switching functionality
        function switchTab(tabId) {
            // Hide all tab panes and unload their iframes (Airtable limitation: only one embed per view ID)
            document.querySelectorAll('.tab-pane').forEach(pane => {
                pane.classList.remove('active');
                
                // Unload iframe to prevent conflicts
                const iframe = pane.querySelector('iframe.airtable-embed');
                if (iframe) {
                    const container = iframe.closest('.iframe-container');
                    const dataSrc = container.getAttribute('data-src');
                    
                    // Replace iframe with loading placeholder
                    container.innerHTML = `
                        <div class="loading-placeholder" style="
                            text-align: center; 
                            padding: 60px 20px; 
                            background: #f8f9fa; 
                            border: 1px solid #ccc; 
                            border-radius: 8px; 
                            color: #666;
                        ">
                            <p>📊 Loading ${getTabDisplayName(pane.id)}...</p>
                            <p style="font-size: 14px; margin-top: 10px;">Will load when tab becomes active</p>
                        </div>
                    `;
                    container.setAttribute('data-src', dataSrc);
                }
            });
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab pane and load its iframe
            const activePane = document.getElementById(tabId);
            activePane.classList.add('active');
            
            // Load iframe for active tab
            const container = activePane.querySelector('.iframe-container');
            if (container) {
                const dataSrc = container.getAttribute('data-src');
                if (dataSrc) {
                    container.innerHTML = `
                        <iframe 
                            class="airtable-embed" 
                            src="${dataSrc}" 
                            frameborder="0" 
                            onmousewheel="" 
                            width="100%" 
                            height="533" 
                            style="background: transparent; border: 1px solid #ccc; border-radius: 8px;">
                        </iframe>
                    `;
                }
            }
            
            // Set active button
            event.target.classList.add('active');
            
            // Generate friendly tab name for logging
            const tabNames = {
                'inventory-list': 'Ideas - List View',
                'inventory-card': 'Ideas - Card View',
                'todo-list': 'To-Do - List View',
                'todo-card': 'To-Do - Card View'
            };
            
            logStatus(`📊 Switched to ${tabNames[tabId] || tabId} (iframe loaded)`);
        }
        
        function getTabDisplayName(tabId) {
            const names = {
                'inventory-list': 'Ideas List View',
                'inventory-card': 'Ideas Card View',
                'todo-list': 'To-Do List View',
                'todo-card': 'To-Do Card View',
                'ready-card': 'Ready View',
                'archive-card': 'Archive View'
            };
            return names[tabId] || tabId;
        }

        // ================================
        // ANALYTICS DASHBOARD FUNCTIONS
        // ================================

        // Analytics: Generate strategic insights based on data
        function generateStrategicInsights(analyticsData) {
            const insights = [];
            
            // Content balance insights
            const localRatio = analyticsData.localContent / analyticsData.totalContent;
            if (localRatio > 0.7) {
                insights.push({
                    type: 'optimization',
                    title: 'High Local Generation Ratio',
                    description: 'Consider systematic generation for visual content needs'
                });
            }
            
            // Priority distribution insights
            if (analyticsData.highPriorityContent > analyticsData.totalContent * 0.5) {
                insights.push({
                    type: 'planning',
                    title: 'High Priority Content Load',
                    description: 'Review priority distribution to ensure realistic scheduling'
                });
            }
            
            // SEO opportunity insights
            if (analyticsData.pestTypes && analyticsData.pestTypes.length > 0) {
                const highOpportunityPests = analyticsData.pestTypes.filter(pest => pest.y > 3 && pest.x > 500);
                if (highOpportunityPests.length > 0) {
                    insights.push({
                        type: 'opportunity',
                        title: 'High-Value SEO Opportunities',
                        description: `Focus on ${highOpportunityPests[0].label} content for maximum ROI`
                    });
                }
            }
            
            return insights;
        }

        // Create Content Type Distribution Chart (Doughnut)
        function createContentTypeChart(data) {
            const ctx = document.getElementById('contentTypeChart').getContext('2d');
            
            if (analyticsCharts.contentType) {
                analyticsCharts.contentType.destroy();
            }
            
            analyticsCharts.contentType = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: data.labels,
                    datasets: [{
                        data: data.data,
                        backgroundColor: data.colors,
                        borderWidth: 2,
                        borderColor: '#ffffff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        },
                        title: {
                            display: true,
                            text: 'Content Type Distribution'
                        }
                    }
                }
            });
        }

        // Create Generation Strategy Chart (Bar)
        function createGenerationTypeChart(data) {
            const ctx = document.getElementById('generationTypeChart').getContext('2d');
            
            if (analyticsCharts.generationType) {
                analyticsCharts.generationType.destroy();
            }
            
            analyticsCharts.generationType = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.labels,
                    datasets: [{
                        label: 'Content Count',
                        data: data.data,
                        backgroundColor: data.colors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Generation Strategy Split'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        // Create Priority Distribution Chart (Horizontal Bar)
        function createPriorityChart(data) {
            const ctx = document.getElementById('priorityChart').getContext('2d');
            
            if (analyticsCharts.priority) {
                analyticsCharts.priority.destroy();
            }
            
            analyticsCharts.priority = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.labels,
                    datasets: [{
                        label: 'Content Count',
                        data: data.data,
                        backgroundColor: data.colors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        title: {
                            display: true,
                            text: 'Priority Distribution'
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        // Create Market Coverage Chart (Polar Area)
        function createLocationChart(data) {
            const ctx = document.getElementById('locationChart').getContext('2d');
            
            if (analyticsCharts.location) {
                analyticsCharts.location.destroy();
            }
            
            analyticsCharts.location = new Chart(ctx, {
                type: 'polarArea',
                data: {
                    labels: data.labels,
                    datasets: [{
                        data: data.data,
                        backgroundColor: data.colors,
                        borderWidth: 2,
                        borderColor: '#ffffff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        },
                        title: {
                            display: true,
                            text: 'Market Coverage by Location'
                        }
                    },
                    scales: {
                        r: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        // Create Seasonal Strategy Chart (Line)
        function createSeasonalChart(data) {
            const ctx = document.getElementById('seasonalChart').getContext('2d');
            
            if (analyticsCharts.seasonal) {
                analyticsCharts.seasonal.destroy();
            }
            
            analyticsCharts.seasonal = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: [{
                        label: 'Content Count',
                        data: data.data,
                        backgroundColor: 'rgba(139, 92, 246, 0.1)',
                        borderColor: '#8b5cf6',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Seasonal Content Strategy'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        // Create SEO Opportunity Map Chart (Bubble)
        function createSEOChart(data) {
            const ctx = document.getElementById('seoChart').getContext('2d');
            
            if (analyticsCharts.seo) {
                analyticsCharts.seo.destroy();
            }
            
            analyticsCharts.seo = new Chart(ctx, {
                type: 'bubble',
                data: {
                    datasets: [{
                        label: 'Pest Type Opportunities',
                        data: data,
                        backgroundColor: 'rgba(139, 92, 246, 0.6)',
                        borderColor: '#8b5cf6',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'SEO Opportunity Map (Search Volume vs Difficulty)'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.parsed;
                                    const dataPoint = data[context.dataIndex];
                                    return [
                                        `${dataPoint.label}`,
                                        `Search Volume: ${point.x}`,
                                        `Difficulty: ${4 - point.y}/3`,
                                        `Content Count: ${dataPoint.count}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Average Search Volume'
                            },
                            beginAtZero: true
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'SEO Opportunity (Easier = Higher)'
                            },
                            min: 0,
                            max: 4,
                            ticks: {
                                callback: function(value) {
                                    const labels = ['Very Hard', 'Hard', 'Medium', 'Easy', 'Very Easy'];
                                    return labels[Math.floor(value)] || '';
                                }
                            }
                        }
                    }
                }
            });
        }

        // Initialize all analytics charts
        function initializeAnalyticsCharts(analyticsData) {
            if (!analyticsData) return;
            
            try {
                createContentTypeChart(analyticsData.contentTypes);
                createGenerationTypeChart(analyticsData.generationTypes);
                createPriorityChart(analyticsData.priorities);
                createLocationChart(analyticsData.locations);
                createSeasonalChart(analyticsData.seasonal);
                createSEOChart(analyticsData.pestTypes);
                
                // Update summary statistics
                updateAnalyticsSummary(analyticsData);
                
                // Generate and display insights
                const insights = generateStrategicInsights(analyticsData);
                updateInsightsPanel(insights);
                
                console.log('📊 Analytics charts initialized successfully');
                
            } catch (error) {
                console.error('Error initializing analytics charts:', error);
            }
        }

        // Update analytics summary statistics
        function updateAnalyticsSummary(data) {
            const summaryHTML = `
                <div class="analytics-summary-grid">
                    <div class="summary-stat">
                        <div class="stat-value">${data.totalContent}</div>
                        <div class="stat-label">Total Content</div>
                    </div>
                    <div class="summary-stat">
                        <div class="stat-value">${data.localContent}</div>
                        <div class="stat-label">Local Generation</div>
                    </div>
                    <div class="summary-stat">
                        <div class="stat-value">${data.systematicContent}</div>
                        <div class="stat-label">Systematic Generation</div>
                    </div>
                    <div class="summary-stat">
                        <div class="stat-value">${data.highPriorityContent}</div>
                        <div class="stat-label">High Priority</div>
                    </div>
                </div>
            `;
            
            const summaryContainer = document.querySelector('.analytics-summary');
            if (summaryContainer) {
                summaryContainer.innerHTML = summaryHTML;
            }
        }

        // Update insights panel
        function updateInsightsPanel(insights) {
            const insightsHTML = insights.map(insight => `
                <div class="insight-item ${insight.type}">
                    <div class="insight-title">${insight.title}</div>
                    <div class="insight-description">${insight.description}</div>
                </div>
            `).join('');
            
            const insightsContainer = document.querySelector('.analytics-insights');
            if (insightsContainer) {
                insightsContainer.innerHTML = insightsHTML || '<div class="insight-item">No strategic insights available yet. Add more content to generate recommendations.</div>';
            }
        }

        // Export chart as PNG
        function exportChart(chartName) {
            const chart = analyticsCharts[chartName];
            if (!chart) return;
            
            const url = chart.toBase64Image();
            const link = document.createElement('a');
            link.download = `client-analytics-${chartName}-${new Date().toISOString().split('T')[0]}.png`;
            link.href = url;
            link.click();
        }

        // Add export buttons functionality
        function initializeExportButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('export-chart-btn')) {
                    const chartName = e.target.dataset.chart;
                    exportChart(chartName);
                }
            });
        }

        // Refresh analytics with latest data
        async function refreshAnalytics() {
            try {
                const response = await fetch('/api/analytics');
                if (!response.ok) return;
                
                const analyticsData = await response.json();
                initializeAnalyticsCharts(analyticsData);
                
                logStatus('📊 Analytics refreshed');
                
            } catch (error) {
                console.error('Error refreshing analytics:', error);
            }
        }

        // Analytics data source management
        let currentDataSource = 'combined'; // Track current data source
        
        // Switch analytics data source
        function switchAnalyticsDataSource() {
            const selector = document.getElementById('analyticsDataSource');
            currentDataSource = selector.value;
            logStatus(`🔄 Switching to ${currentDataSource} data source...`);
            loadAnalyticsData();
        }
        
        // Refresh analytics
        function refreshAnalytics() {
            logStatus('🔄 Refreshing analytics...');
            loadAnalyticsData();
        }
        
        // Load analytics data from sync bridge with data source filtering
        async function loadAnalyticsData() {
            try {
                const response = await fetch('/api/analytics');
                if (response.ok) {
                    const analyticsData = await response.json();
                    initializeAnalyticsCharts(analyticsData);
                    return;
                }
            } catch (error) {
                console.log('📊 Using local data for analytics');
            }
            
            // Fallback to local content data if API not available
            if (window.contentData && window.contentData.length > 0) {
                const analyticsData = generateAnalyticsFromContentData(window.contentData, currentDataSource);
                initializeAnalyticsCharts(analyticsData);
            }
        }

        // Generate analytics data with data source filtering
        function generateAnalyticsFromContentData(contentData, dataSource = 'combined') {
            let filteredData = [];
            
            // Filter data based on source selection
            switch (dataSource) {
                case 'local':
                    filteredData = contentData.filter(item => item.source === 'claude' || item.generationType === 'LOCAL');
                    break;
                case 'airtable':
                    filteredData = contentData.filter(item => item.source === 'airtable' || item.generationType === 'SYSTEMATIC');
                    break;
                case 'combined':
                default:
                    filteredData = contentData;
                    break;
            }
            
            console.log(`📊 Analytics using ${dataSource} data: ${filteredData.length} items`);
            
            // Generate analytics from filtered data
            const analyticsData = {
                totalContent: filteredData.length,
                localContent: filteredData.filter(item => item.generationType === 'LOCAL' || item.source === 'claude').length,
                systematicContent: filteredData.filter(item => item.generationType === 'SYSTEMATIC' || item.source === 'airtable').length,
                highPriorityContent: filteredData.filter(item => (item.priority || 'MEDIUM') === 'HIGH').length,
                
                // Content type distribution
                contentTypes: {
                    labels: [...new Set(filteredData.map(item => item.contentType || 'Unknown'))],
                    data: [],
                    colors: ['#8b5cf6', '#f59e0b', '#06b6d4', '#ef4444', '#ec4899', '#10b981']
                },
                
                // Generation type split
                generationTypes: {
                    labels: ['LOCAL', 'SYSTEMATIC'],
                    data: [
                        filteredData.filter(item => item.generationType === 'LOCAL' || item.source === 'claude').length,
                        filteredData.filter(item => item.generationType === 'SYSTEMATIC' || item.source === 'airtable').length
                    ],
                    colors: ['#8b5cf6', '#06b6d4']
                },
                
                // Priority distribution
                priorities: {
                    labels: ['HIGH', 'MEDIUM', 'LOW'],
                    data: [
                        filteredData.filter(item => (item.priority || 'MEDIUM') === 'HIGH').length,
                        filteredData.filter(item => (item.priority || 'MEDIUM') === 'MEDIUM').length,
                        filteredData.filter(item => (item.priority || 'MEDIUM') === 'LOW').length
                    ],
                    colors: ['#dc2626', '#d97706', '#16a34a']
                },
                
                lastUpdated: new Date().toISOString()
            };
            
            // Calculate content type data
            const contentTypeCount = {};
            filteredData.forEach(item => {
                const type = item.contentType || 'Unknown';
                contentTypeCount[type] = (contentTypeCount[type] || 0) + 1;
            });
            analyticsData.contentTypes.data = analyticsData.contentTypes.labels.map(label => contentTypeCount[label] || 0);
            
            return analyticsData;
        }
        
        // Google Drive iframe functions
        function refreshDriveIframe() {
            const iframe = document.getElementById('googleDriveIframe');
            if (iframe && iframe.src) {
                iframe.src = iframe.src;
                logStatus('🔄 Google Drive iframe refreshed');
            } else {
                logStatus('⚠️ Google Drive not configured - please set up folder URL first');
            }
        }

        function openDriveInNewTab() {
            window.open('https://drive.google.com/', '_blank');
            logStatus('🔗 Opened Google Drive in new tab');
        }

        // Integration settings persistence
        function loadIntegrationSettings() {
            const settings = localStorage.getItem('client_integration_settings');
            return settings ? JSON.parse(settings) : {
                googleDriveFolderId: '',
                airtableApiUrl: AIRTABLE_CONFIG.apiUrl,
                airtableBaseId: AIRTABLE_CONFIG.baseId,
                airtableTableId: AIRTABLE_CONFIG.tableId,
                useDirectApi: true // Now using direct Airtable API instead of N8N webhook
            };
        }
        
        function saveIntegrationSettings(settings) {
            localStorage.setItem('client_integration_settings', JSON.stringify(settings));
            logStatus('💾 Integration settings saved persistently');
        }
        
        function setupGoogleDrive() {
            const settings = loadIntegrationSettings();
            const currentId = settings.googleDriveFolderId;
            
            const folderId = prompt(`Enter your Google Drive folder ID:\n\nCurrent: ${currentId || 'Not set'}\n\nTo get this:\n1. Open your Google Drive folder\n2. Copy the folder ID from the URL\n3. Paste it here\n\nExample: if URL is drive.google.com/drive/folders/1ABC123...\nThen folder ID is: 1ABC123...`, currentId);
            
            if (folderId && folderId.trim()) {
                const iframe = document.getElementById('googleDriveIframe');
                const setupMessage = document.getElementById('driveSetupMessage');
                
                const driveUrl = `https://drive.google.com/embeddedfolderview?id=${folderId.trim()}&usp=sharing`;
                iframe.src = driveUrl;
                iframe.style.display = 'block';
                setupMessage.style.display = 'none';
                
                // Save the setting persistently
                settings.googleDriveFolderId = folderId.trim();
                saveIntegrationSettings(settings);
                
                logStatus('📁 Google Drive configured and saved for future sessions');
            }
        }
        
        function loadPersistedGoogleDrive() {
            const settings = loadIntegrationSettings();
            if (settings.googleDriveFolderId) {
                const iframe = document.getElementById('googleDriveIframe');
                const setupMessage = document.getElementById('driveSetupMessage');
                const driveUrl = `https://drive.google.com/embeddedfolderview?id=${settings.googleDriveFolderId}&usp=sharing`;
                
                iframe.src = driveUrl;
                iframe.style.display = 'block';
                setupMessage.style.display = 'none';
                
                logStatus('📁 Google Drive loaded from saved settings');
                return true;
            }
            return false;
        }

        // Generate analytics data from content data array
        function generateAnalyticsFromContentData(contentData) {
            // Content Type Distribution
            const contentTypeData = {};
            contentData.forEach(record => {
                const type = record.contentType || 'Unknown';
                contentTypeData[type] = (contentTypeData[type] || 0) + 1;
            });

            // Generation Type Split
            const generationTypeData = {
                LOCAL: contentData.filter(r => r.generationType === 'LOCAL').length,
                SYSTEMATIC: contentData.filter(r => r.generationType === 'SYSTEMATIC').length
            };

            // Priority Distribution
            const priorityData = {};
            contentData.forEach(record => {
                const priority = record.priority || 'MEDIUM';
                priorityData[priority] = (priorityData[priority] || 0) + 1;
            });

            // Location Coverage
            const locationData = {};
            contentData.forEach(record => {
                const location = record.targetLocation || 'Unknown';
                locationData[location] = (locationData[location] || 0) + 1;
            });

            // Pest Type Analysis
            const pestTypeData = [];
            const pestTypes = {};
            contentData.forEach(record => {
                const pestType = record.pestType || 'General';
                if (!pestTypes[pestType]) {
                    pestTypes[pestType] = {
                        name: pestType,
                        count: 0,
                        totalSearchVolume: 0,
                        difficulties: []
                    };
                }
                pestTypes[pestType].count += 1;
                
                const searchVolume = parseInt(record.searchVolume || 0);
                pestTypes[pestType].totalSearchVolume += searchVolume;
                
                const difficulty = record.keywordDifficulty || 'Medium';
                const difficultyValue = difficulty === 'Low' ? 1 : difficulty === 'Medium' ? 2 : 3;
                pestTypes[pestType].difficulties.push(difficultyValue);
            });

            // Convert to bubble chart format
            Object.keys(pestTypes).forEach(pestType => {
                const data = pestTypes[pestType];
                const avgSearchVolume = data.count > 0 ? data.totalSearchVolume / data.count : 0;
                const avgDifficulty = data.difficulties.length > 0 ? 
                    data.difficulties.reduce((a, b) => a + b, 0) / data.difficulties.length : 2;
                
                pestTypeData.push({
                    x: avgSearchVolume,
                    y: 4 - avgDifficulty, // Invert difficulty (higher = easier)
                    r: data.count * 5 + 5, // Bubble size
                    label: pestType,
                    count: data.count
                });
            });

            // Seasonal Distribution
            const seasonalData = {
                'Spring': 0,
                'Summer': 0,
                'Fall': 0,
                'Winter': 0,
                'Year-Round': 0
            };
            contentData.forEach(record => {
                const season = record.seasonalRelevance || 'Year-Round';
                if (seasonalData.hasOwnProperty(season)) {
                    seasonalData[season] += 1;
                } else {
                    seasonalData['Year-Round'] += 1;
                }
            });

            return {
                contentTypes: {
                    labels: Object.keys(contentTypeData),
                    data: Object.values(contentTypeData),
                    colors: [
                        '#8b5cf6', // Purple - Blog Posts
                        '#f59e0b', // Amber - Social Media
                        '#06b6d4', // Cyan - Location Pages
                        '#ef4444', // Red - Email
                        '#ec4899', // Pink - Video
                        '#10b981'  // Green - Other
                    ]
                },
                generationTypes: {
                    labels: Object.keys(generationTypeData),
                    data: Object.values(generationTypeData),
                    colors: ['#8b5cf6', '#06b6d4'] // Purple (LOCAL), Cyan (SYSTEMATIC)
                },
                priorities: {
                    labels: Object.keys(priorityData),
                    data: Object.values(priorityData),
                    colors: ['#dc2626', '#d97706', '#16a34a'] // Red (HIGH), Orange (MEDIUM), Green (LOW)
                },
                locations: {
                    labels: Object.keys(locationData),
                    data: Object.values(locationData),
                    colors: [
                        '#3b82f6', // Blue - Illinois
                        '#8b5cf6', // Purple - Iowa
                        '#10b981', // Green - Wisconsin
                        '#f59e0b'  // Amber - Other
                    ]
                },
                pestTypes: pestTypeData,
                seasonal: {
                    labels: Object.keys(seasonalData),
                    data: Object.values(seasonalData),
                    colors: [
                        '#22c55e', // Green - Spring
                        '#f59e0b', // Amber - Summer
                        '#f97316', // Orange - Fall
                        '#3b82f6', // Blue - Winter
                        '#6b7280'  // Gray - Year-Round
                    ]
                },
                totalContent: contentData.length,
                localContent: contentData.filter(r => r.generationType === 'LOCAL').length,
                systematicContent: contentData.filter(r => r.generationType === 'SYSTEMATIC').length,
                highPriorityContent: contentData.filter(r => (r.priority || 'MEDIUM') === 'HIGH').length,
                lastUpdated: new Date().toISOString()
            };
        }
        
        // ULTIMATE WIDTH FIX - Force exact same pixel width with !important override
        function forceWidthFix() {
            const dashboard = document.querySelector('.dashboard');
            const dashboardWidth = dashboard.getBoundingClientRect().width;
            const targetWidth = dashboardWidth - 32; // Account for container padding
            
            const sections = document.querySelectorAll('.collapsible-section');
            sections.forEach(section => {
                section.style.setProperty('width', targetWidth + 'px', 'important');
                section.style.setProperty('max-width', targetWidth + 'px', 'important');
                section.style.setProperty('min-width', targetWidth + 'px', 'important');
                section.style.setProperty('box-sizing', 'border-box', 'important');
                section.style.setProperty('grid-column', '1', 'important');
                section.style.setProperty('margin', '0 auto 20px auto', 'important');
                section.style.setProperty('padding', '0', 'important');
            });
            console.log('✅ Ultimate width fix applied:', targetWidth + 'px to', sections.length, 'sections');
        }
        
        // Apply fix when page loads
        document.addEventListener('DOMContentLoaded', forceWidthFix);
        
        // Apply fix again after a short delay (in case of dynamic content)
        setTimeout(forceWidthFix, 100);
        
        // Apply fix whenever window resizes
        window.addEventListener('resize', forceWidthFix);
        
        // Apply fix whenever sections are toggled
        document.addEventListener('click', function(e) {
            if (e.target.closest('.collapsible-header')) {
                setTimeout(forceWidthFix, 50);
            }
        });
        setTimeout(forceWidthFix, 500);
        
        // Global debugging function for troubleshooting
        window.debugDashboardState = function() {
            console.log('=== DASHBOARD DEBUG STATE ===');
            console.log('window.contentData:', window.contentData?.length || 0, 'items');
            console.log('cardsContainer exists:', !!document.getElementById('cardsContainer'));
            console.log('cardsEmptyState exists:', !!document.getElementById('cardsEmptyState'));
            console.log('calendar disabled (staging dashboard)');
            console.log('API server status:');
            fetch('http://localhost:3002/api/planning-state')
                .then(r => r.json())
                .then(data => console.log('API response:', data))
                .catch(e => console.log('API error:', e));
            console.log('===========================');
        };
        
        // Auto-run debug after page load
        setTimeout(() => {
            console.log('🔍 Auto-debug after page load:');
            window.debugDashboardState();
        }, 2000);

        
        async function restoreArchive(filename) {
            if (!confirm(`Restore "${filename}"?\n\nThis will replace current staging area contents with the archived planning session.`)) {
                return;
            }
            
            console.log('🔄 Restoring archive:', filename);
            logStatus(`🔄 Restoring ${filename}...`);
            
            try {
                const response = await fetch(`http://localhost:3002/api/restore-archive`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ filename: filename })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                // Refresh the main dashboard with forceReplace to ensure restored content shows
                await loadFromClaude(true);
                
                // Switch to main dashboard area to show restored content
                const mainArea = document.querySelector('#cardsContainer');
                if (mainArea) {
                    mainArea.scrollIntoView({ behavior: 'smooth' });
                }
                
                logStatus(`✅ Successfully restored ${result.recordCount} records from ${filename}`);
                
            } catch (error) {
                console.error('Error restoring archive:', error);
                logStatus(`❌ Failed to restore ${filename}`);
                alert('Failed to restore archive. Please check the console for details.');
            }
        }
        
        // Wrapper function for compatibility with onclick calls from archive list
        window.restoreFromArchive = function(filename) {
            restoreArchive(filename);
        };
        
        async function previewArchive(filename) {
            console.log('👁️ Previewing archive:', filename);
            
            try {
                const response = await fetch(`http://localhost:3002/api/preview-archive`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ filename: filename })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const archiveData = await response.json();
                
                // Fix data structure - API returns 'records' not 'content_records'
                const records = archiveData.records || archiveData.content_records || [];
                const timestamp = archiveData.archivedAt || archiveData.timestamp;
                
                // Create a preview modal
                let previewHTML = `
                    <div style="
                        position: fixed; 
                        top: 0; 
                        left: 0; 
                        width: 100%; 
                        height: 100%; 
                        background: rgba(0,0,0,0.7); 
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        z-index: 10000;
                    " onclick="this.remove()">
                        <div style="
                            background: white; 
                            border-radius: 12px; 
                            max-width: 800px; 
                            max-height: 80vh; 
                            overflow-y: auto; 
                            padding: 24px; 
                            margin: 20px;
                            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
                        " onclick="event.stopPropagation()">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #e5e7eb; padding-bottom: 16px;">
                                <h3 style="margin: 0; color: #374151;">📦 Archive Preview: ${filename}</h3>
                                <button class="archive-close-x-btn" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #6b7280;">×</button>
                            </div>
                            <div style="color: #6b7280; margin-bottom: 20px;">
                                <div><strong>Created:</strong> ${new Date(timestamp).toLocaleString()}</div>
                                <div><strong>Records:</strong> ${records.length}</div>
                                <div><strong>Generated Content:</strong> ${records.filter(r => r.generationStatus === 'generated').length}</div>
                            </div>
                            <div style="max-height: 400px; overflow-y: auto;">
                `;
                
                records.forEach((record, index) => {
                    previewHTML += `
                        <div style="
                            border: 1px solid #e5e7eb; 
                            border-radius: 6px; 
                            padding: 12px; 
                            margin-bottom: 8px; 
                            background: ${record.generationStatus === 'generated' ? '#f0fdf4' : '#f9fafb'};
                        ">
                            <div style="font-weight: 600; color: #374151; margin-bottom: 4px;">
                                ${record.description}
                            </div>
                            <div style="font-size: 14px; color: #6b7280;">
                                ${record.contentType} • ${record.priority} Priority • ${record.generationType || 'N/A'}
                                ${record.generationStatus === 'generated' ? '• ✅ Generated' : ''}
                            </div>
                            ${record.wordCount ? `<div style="font-size: 12px; color: #6b7280; margin-top: 4px;">${record.wordCount} words</div>` : ''}
                        </div>
                    `;
                });
                
                previewHTML += `
                            </div>
                            <div style="margin-top: 20px; text-align: right; border-top: 1px solid #e5e7eb; padding-top: 16px;">
                                <button data-restore="${filename}" class="archive-restore-btn" style="background: #10b981; color: white; border: none; border-radius: 6px; padding: 10px 20px; font-size: 14px; cursor: pointer; margin-right: 8px;">
                                    🔄 Restore This Archive
                                </button>
                                <button class="archive-close-btn" style="background: #6b7280; color: white; border: none; border-radius: 6px; padding: 10px 20px; font-size: 14px; cursor: pointer;">
                                    Close
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', previewHTML);
                
                // Add event listeners after inserting HTML
                const modal = document.querySelector('div[style*="position: fixed"][style*="z-index: 10000"]:last-of-type');
                const restoreBtn = modal.querySelector('.archive-restore-btn');
                const closeBtn = modal.querySelector('.archive-close-btn');
                const closeXBtn = modal.querySelector('.archive-close-x-btn');
                
                // Close modal when clicking overlay
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                    }
                });
                
                // Prevent modal close when clicking content
                modal.querySelector('div[style*="background: white"]').addEventListener('click', function(e) {
                    e.stopPropagation();
                });
                
                // Restore button event
                restoreBtn.addEventListener('click', function() {
                    const filename = this.getAttribute('data-restore');
                    document.body.removeChild(modal);
                    restoreArchive(filename);
                });
                
                // Close button events
                closeBtn.addEventListener('click', function() {
                    document.body.removeChild(modal);
                });
                
                closeXBtn.addEventListener('click', function() {
                    document.body.removeChild(modal);
                });
                
            } catch (error) {
                console.error('Error previewing archive:', error);
                alert('Failed to preview archive. Please check the console for details.');
            }
        }

        // Archive system initialization - removed tab switching hook since archive is a collapsible section, not a tab
    </script>

    <!-- Content Creation Modal -->
    <div id="contentModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">
                    <span>📝</span>
                    Create New Content
                </div>
                <button class="modal-close" onclick="closeContentModal()">×</button>
            </div>
            
            <div class="date-info" id="modalDateInfo">
                <span>📅</span>
                <span id="modalDateText">Publishing date: August 25, 2025</span>
            </div>
            
            <form id="contentForm">
                <div class="form-group">
                    <label class="form-label" for="contentDescription">Content Description*</label>
                    <input type="text" id="contentDescription" class="form-input" 
                           placeholder="e.g., Fall Pest Prevention Guide for Dixon, IL" required>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label" for="contentType">Content Type*</label>
                        <select id="contentType" class="form-select" required>
                            <option value="Blog Post">📝 Blog Post</option>
                            <option value="Social Media">📱 Social Media</option>
                            <option value="Location Page">📍 Location Page</option>
                            <option value="Email">📧 Email</option>
                            <option value="Video">🎥 Video</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="contentPriority">Priority*</label>
                        <select id="contentPriority" class="form-select" required>
                            <option value="HIGH">🔴 HIGH</option>
                            <option value="MEDIUM" selected>🟡 MEDIUM</option>
                            <option value="LOW">🟢 LOW</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label" for="targetLocation">Target Location</label>
                        <select id="targetLocation" class="form-select">
                            <option value="Multi-State">Multi-State</option>
                            <option value="Dixon IL">Dixon IL</option>
                            <option value="Rockford IL">Rockford IL</option>
                            <option value="DeKalb IL">DeKalb IL</option>
                            <option value="Sycamore IL">Sycamore IL</option>
                            <option value="Iowa">Iowa</option>
                            <option value="Wisconsin">Wisconsin</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="pestType">Pest Type</label>
                        <select id="pestType" class="form-select">
                            <option value="General">General</option>
                            <option value="Bed Bugs">Bed Bugs</option>
                            <option value="Termites">Termites</option>
                            <option value="Ants">Ants</option>
                            <option value="Rodents">Rodents</option>
                            <option value="Mosquitoes">Mosquitoes</option>
                            <option value="Wasps">Wasps</option>
                            <option value="Spiders">Spiders</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="primaryKeywords">Primary Keywords</label>
                    <input type="text" id="primaryKeywords" class="form-input" 
                           placeholder="e.g., pest control Dixon IL, fall pest prevention">
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="contentNotes">Notes</label>
                    <textarea id="contentNotes" class="form-textarea" 
                              placeholder="Additional details, requirements, or context..."></textarea>
                </div>
            </form>
            
            <div class="modal-actions">
                <button type="button" class="btn-modal btn-cancel" onclick="closeContentModal()">
                    Cancel
                </button>
                <button type="button" class="btn-modal btn-create" onclick="createContentFromModal()" id="createBtn">
                    🏗️ Create Infrastructure
                </button>
            </div>
        </div>
    </div>

    <!-- Content Details Modal -->
    <div id="contentDetailsModal" class="modal-overlay">
        <div class="content-details-modal">
            <div class="details-header">
                <h2 class="details-title" id="detailsTitle">Content Title</h2>
                <div class="details-meta" id="detailsMeta">
                    <!-- Dynamic meta items -->
                </div>
            </div>
            
            <div class="details-body">
                <!-- Content Description -->
                <div class="details-section">
                    <h3>📄 Description</h3>
                    <div class="details-content" id="detailsDescription">
                        <!-- Dynamic description -->
                    </div>
                </div>
                
                <!-- Keywords -->
                <div class="details-section" id="keywordsSection">
                    <h3>🔑 Primary Keywords</h3>
                    <div class="keywords-list" id="keywordsList">
                        <!-- Dynamic keyword tags -->
                    </div>
                </div>
                
                <!-- Notes -->
                <div class="details-section" id="notesSection">
                    <h3>📝 Notes</h3>
                    <div class="details-content" id="detailsNotes">
                        <!-- Dynamic notes -->
                    </div>
                </div>
                
                <!-- File Access -->
                <div class="details-section">
                    <h3>📁 File & Asset Access</h3>
                    <div class="file-access-section" id="fileAccessSection">
                        <div class="file-access-icon">📁</div>
                        <p><strong>Content Infrastructure</strong></p>
                        <p id="fileStatusText">Google Drive folder and Airtable record for collaborative content development</p>
                        <div class="file-links" id="fileLinks">
                            <!-- Dynamic file links -->
                        </div>
                    </div>
                </div>
                
                <!-- Selection Toggle -->
                <div class="selection-toggle">
                    <input type="checkbox" id="detailsSelectionToggle" onchange="toggleContentSelection()">
                    <label for="detailsSelectionToggle">
                        <strong>Include in Submission</strong> - Add this content to your next Airtable submission
                    </label>
                </div>
            </div>
            
            <div class="details-actions">
                <div class="action-group">
                    <button type="button" class="btn-secondary" onclick="editContentInline()">
                        ✏️ Edit Details
                    </button>
                    <button type="button" class="btn-secondary btn-danger" onclick="deleteContentFromModal()">
                        🗑️ Delete
                    </button>
                </div>
                <button type="button" class="btn-secondary" onclick="closeContentDetailsModal()">
                    Close
                </button>
            </div>
        </div>
    </div>

    <script>
        let currentDetailsRecord = null;

        function showContentDetailsCard(record) {
            currentDetailsRecord = record;
            
            // Update modal content
            document.getElementById('detailsTitle').textContent = record.description || 'Untitled Content';
            
            // Update meta information
            const metaContainer = document.getElementById('detailsMeta');
            metaContainer.innerHTML = `
                <div class="meta-item">
                    <span class="content-type-badge">${record.contentType || 'Blog Post'}</span>
                </div>
                <div class="meta-item">
                    <span class="priority-badge priority-${record.priority || 'MEDIUM'}">${record.priority || 'MEDIUM'}</span>
                </div>
                <div class="meta-item">
                    📍 ${record.targetLocation || 'Multi-State'}
                </div>
                <div class="meta-item">
                    🐛 ${record.pestType || 'General'}
                </div>
                <div class="meta-item">
                    📅 ${record.targetPublishDate || 'No date set'}
                </div>
            `;
            
            // Update description
            document.getElementById('detailsDescription').textContent = record.description || 'No description provided';
            
            // Update keywords
            const keywordsSection = document.getElementById('keywordsSection');
            const keywordsList = document.getElementById('keywordsList');
            if (record.primaryKeyword && record.primaryKeyword.trim()) {
                keywordsSection.style.display = 'block';
                const keywords = record.primaryKeyword.split(',').map(k => k.trim()).filter(k => k);
                keywordsList.innerHTML = keywords.map(keyword => 
                    `<span class="keyword-tag">${keyword}</span>`
                ).join('');
            } else {
                keywordsSection.style.display = 'none';
            }
            
            // Update notes
            const notesSection = document.getElementById('notesSection');
            const detailsNotes = document.getElementById('detailsNotes');
            if (record.notes && record.notes.trim()) {
                notesSection.style.display = 'block';
                detailsNotes.textContent = record.notes;
            } else {
                notesSection.style.display = 'none';
            }
            
            // Update file access section
            updateFileAccessSection(record);
            
            // Update selection toggle
            document.getElementById('detailsSelectionToggle').checked = record.selected || false;
            
            // Show modal
            const modal = document.getElementById('contentDetailsModal');
            modal.classList.add('active');
            
            logStatus(`📋 Viewing details: "${record.description}"`);
        }
        
        function updateFileAccessSection(record) {
            const fileLinks = document.getElementById('fileLinks');
            const fileStatusText = document.getElementById('fileStatusText');
            
            let hasFiles = false;
            let linksHtml = '';
            
            // Airtable record link
            if (record.airtableId) {
                linksHtml += `
                    <a href="https://airtable.com/appS6XjjRUrELJRgC/tblCR8yF9HHQlDij1/${record.airtableId}" 
                       target="_blank" class="file-link">
                        📊 Airtable Record
                    </a>
                `;
                hasFiles = true;
            }
            
            // Google Drive folder link
            if (record.folderLink) {
                linksHtml += `
                    <a href="${record.folderLink}" target="_blank" class="file-link">
                        📁 Drive Folder
                    </a>
                `;
                hasFiles = true;
            }
            
            // Content creation workflow link (if local)
            if (record.source === 'calendar-infrastructure' || record.infrastructureReady) {
                linksHtml += `
                    <a href="#" onclick="alert('Content infrastructure ready for development!')" class="file-link">
                        🏗️ Infrastructure Ready
                    </a>
                `;
                hasFiles = true;
            }
            
            if (hasFiles) {
                fileStatusText.textContent = 'Ready for collaborative development with full infrastructure setup';
                fileLinks.innerHTML = linksHtml;
            } else {
                fileStatusText.textContent = 'Local content record - submit to Airtable to create infrastructure';
                fileLinks.innerHTML = `
                    <div style="color: #6b7280; font-style: italic;">
                        Submit this content to create Google Drive folder and Airtable record
                    </div>
                `;
            }
        }
        
        function toggleContentSelection() {
            if (currentDetailsRecord) {
                currentDetailsRecord.selected = document.getElementById('detailsSelectionToggle').checked;
                currentDetailsRecord.modified_at = new Date().toISOString();
                
                // Update calendar and table views
                if (false) { // Calendar disabled
                    // Calendar disabled: const calendarEvent = window.fullCalendarInstance.getEventById(currentDetailsRecord.id);
                    if (calendarEvent) {
                        updateCalendarEventAppearance(calendarEvent, currentDetailsRecord);
                    }
                }
                
                populateCards();
                updateCalendarStats();
                updateSummaryStats();
                updateCommitButton();
                syncToClaude();
                
                logStatus(`${currentDetailsRecord.selected ? '✅ Selected' : '❌ Deselected'}: "${currentDetailsRecord.description}"`);
            }
        }
        
        function editContentInline() {
            // CRITICAL: Preserve record reference before closing modal
            const record = currentDetailsRecord;
            if (!record) {
                logStatus('❌ No record selected for editing');
                return;
            }
            
            // Close the modal first
            closeContentDetailsModal();
            
            // For Airtable records, we need a proper edit modal since they aren't in the local planning table
            // Create an inline edit modal for Airtable records
            showContentEditModal(record);
        }
        
        function showContentEditModal(record) {
            // Create edit modal HTML dynamically with modern card-based design
            const editModalHtml = `
                <div id="contentEditModal" class="modal-overlay active">
                    <div class="modal-content modern-edit-modal">
                        <div class="modal-header-modern">
                            <div class="header-left">
                                <h2 class="modal-title">✏️ Edit Content Details</h2>
                                <p class="modal-subtitle">Update your content information and settings</p>
                            </div>
                            <div class="header-right">
                                <span class="content-type-badge ${(record.contentType || 'Blog Post').toLowerCase().replace(/\s+/g, '-')}">${record.contentType || 'Blog Post'}</span>
                                <span class="priority-badge priority-${(record.priority || 'MEDIUM').toLowerCase()}">${record.priority || 'MEDIUM'}</span>
                            </div>
                        </div>
                        
                        <form id="contentEditForm" class="modern-edit-form">
                            <!-- Description Section -->
                            <div class="form-section">
                                <div class="form-group-modern">
                                    <label for="editDescription" class="form-label-modern">
                                        <span class="label-icon">📄</span>
                                        <span class="label-text">Description</span>
                                    </label>
                                    <textarea id="editDescription" class="form-input-modern textarea-modern" rows="3" required placeholder="Describe your content piece...">${record.description || ''}</textarea>
                                </div>
                            </div>
                            
                            <!-- Content & Priority Section -->
                            <div class="form-section">
                                <div class="form-grid">
                                    <div class="form-group-modern">
                                        <label for="editContentType" class="form-label-modern">
                                            <span class="label-icon">📝</span>
                                            <span class="label-text">Content Type</span>
                                        </label>
                                        <select id="editContentType" class="form-input-modern select-modern" required>
                                            <option value="Blog Post" ${record.contentType === 'Blog Post' ? 'selected' : ''}>Blog Post</option>
                                            <option value="Location Service Page" ${record.contentType === 'Location Service Page' ? 'selected' : ''}>Location Service Page</option>
                                            <option value="Social Media" ${record.contentType === 'Social Media' ? 'selected' : ''}>Social Media</option>
                                            <option value="Email" ${record.contentType === 'Email' ? 'selected' : ''}>Email</option>
                                            <option value="Video" ${record.contentType === 'Video' ? 'selected' : ''}>Video</option>
                                        </select>
                                    </div>
                                    
                                    <div class="form-group-modern">
                                        <label for="editPriority" class="form-label-modern">
                                            <span class="label-icon">⚡</span>
                                            <span class="label-text">Priority</span>
                                        </label>
                                        <select id="editPriority" class="form-input-modern select-modern" required>
                                            <option value="HIGH" ${record.priority === 'HIGH' ? 'selected' : ''}>HIGH</option>
                                            <option value="MEDIUM" ${record.priority === 'MEDIUM' ? 'selected' : ''}>MEDIUM</option>
                                            <option value="LOW" ${record.priority === 'LOW' ? 'selected' : ''}>LOW</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Location & Pest Type Section -->
                            <div class="form-section">
                                <div class="form-grid">
                                    <div class="form-group-modern">
                                        <label for="editTargetLocation" class="form-label-modern">
                                            <span class="label-icon">📍</span>
                                            <span class="label-text">Target Location</span>
                                        </label>
                                        <input type="text" id="editTargetLocation" class="form-input-modern" value="${record.targetLocation || ''}" placeholder="e.g., Illinois, Chicago">
                                    </div>
                                    
                                    <div class="form-group-modern">
                                        <label for="editPestType" class="form-label-modern">
                                            <span class="label-icon">🐛</span>
                                            <span class="label-text">Pest Type</span>
                                        </label>
                                        <input type="text" id="editPestType" class="form-input-modern" value="${record.pestType || ''}" placeholder="e.g., Spiders, Ants, General">
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Keywords Section -->
                            <div class="form-section">
                                <div class="form-group-modern">
                                    <label for="editPrimaryKeywords" class="form-label-modern">
                                        <span class="label-icon">🔑</span>
                                        <span class="label-text">Primary Keywords</span>
                                    </label>
                                    <textarea id="editPrimaryKeywords" class="form-input-modern textarea-modern" rows="2" placeholder="Enter keywords separated by commas">${record.primaryKeywords || ''}</textarea>
                                </div>
                            </div>
                            
                            <!-- Notes & Date Section -->
                            <div class="form-section">
                                <div class="form-group-modern">
                                    <label for="editNotes" class="form-label-modern">
                                        <span class="label-icon">📝</span>
                                        <span class="label-text">Notes</span>
                                    </label>
                                    <textarea id="editNotes" class="form-input-modern textarea-modern" rows="3" placeholder="Additional notes about this content">${record.notes || ''}</textarea>
                                </div>
                                
                                <div class="form-group-modern">
                                    <label for="editTargetPublishDate" class="form-label-modern">
                                        <span class="label-icon">📅</span>
                                        <span class="label-text">Target Publish Date</span>
                                    </label>
                                    <input type="date" id="editTargetPublishDate" class="form-input-modern date-input-modern" value="${record.targetPublishDate || ''}">
                                </div>
                            </div>
                        </form>
                        
                        <div class="modal-actions-modern">
                            <button type="button" class="btn-save-modern" onclick="saveContentEdits('${record.id}')">
                                <span class="btn-icon">💾</span>
                                <span class="btn-text">Save Changes</span>
                            </button>
                            <button type="button" class="btn-cancel-modern" onclick="cancelContentEdit()">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Remove any existing edit modal
            const existingModal = document.getElementById('contentEditModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Add the edit modal to the page
            document.body.insertAdjacentHTML('beforeend', editModalHtml);
            
            logStatus(`✏️ Editing "${record.description}"`);
        }
        
        function saveContentEdits(recordId) {
            const form = document.getElementById('contentEditForm');
            const formData = new FormData(form);
            
            // Find the record in contentData
            const record = window.contentData.find(r => r.id === recordId);
            if (!record) {
                logStatus('❌ Record not found for editing');
                return;
            }
            
            // Update record with form values
            record.description = document.getElementById('editDescription').value;
            record.contentType = document.getElementById('editContentType').value;
            record.priority = document.getElementById('editPriority').value;
            record.targetLocation = document.getElementById('editTargetLocation').value;
            record.pestType = document.getElementById('editPestType').value;
            record.primaryKeywords = document.getElementById('editPrimaryKeywords').value;
            record.notes = document.getElementById('editNotes').value;
            record.targetPublishDate = document.getElementById('editTargetPublishDate').value;
            
            // Mark as user modified for tracking
            record.modified_at = new Date().toISOString();
            record.source = 'edit_modal';
            markUserModified(record, 'edit');
            
            // Close edit modal
            cancelContentEdit();
            
            // CRITICAL: Refresh the cards display to show updated values
            populateCards();
            
            // Refresh calendar and other views
            if (false) { // Calendar disabled
                // window.fullCalendarInstance.refetchEvents(); // Calendar disabled
            }
            updateCalendarStats();
            
            // Sync changes
            syncToClaude();
            
            logStatus(`✅ Updated "${record.description}"`);
        }
        
        function cancelContentEdit() {
            const modal = document.getElementById('contentEditModal');
            if (modal) {
                modal.remove();
            }
        }
        
        function deleteContentFromModal() {
            if (currentDetailsRecord && confirm(`Delete "${currentDetailsRecord.description}"?`)) {
                deleteRow(currentDetailsRecord.id);
                closeContentDetailsModal();
            }
        }
        
        function closeContentDetailsModal() {
            const modal = document.getElementById('contentDetailsModal');
            modal.classList.remove('active');
            currentDetailsRecord = null;
        }
        
        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('contentDetailsModal');
            if (e.target === modal) {
                closeContentDetailsModal();
            }
        });
        
        // Update the existing escape key handler to handle both modals
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const detailsModal = document.getElementById('contentDetailsModal');
                const contentModal = document.getElementById('contentModal');
                
                if (detailsModal && detailsModal.classList.contains('active')) {
                    closeContentDetailsModal();
                } else if (contentModal && contentModal.classList.contains('active')) {
                    closeContentModal();
                }
            }
        });
    </script>

</body>
</html>